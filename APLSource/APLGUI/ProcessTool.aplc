:Class ProcessTool
⍝ Use this class in order to put a selection, either as a list or as a table
⍝ on display and then allow the user to process selected items without
⍝ leaving the GUI.
⍝
⍝ By default the GUI presents a button "Process" and a button "Close".\\
⍝ The modal method requires not only a list (or table) but also the name
⍝ of a callback function that does the processing.\\
⍝ See the `Create` method for more details.\\
⍝ Author: Kai Jaeger ⋄ Copyright: APL Team Ltd

    :Include SelAndProcess

    ⎕IO←0 ⋄ ⎕ML←3

    :Field Public Shared ReadOnly RefreshEvent←9999
    :Field Public Shared ReadOnly QuitEvent←9998

    ∇ r←ListHelpers
      :Access Public Shared
      r←↑'Run' ''
    ∇

    ∇ {r}←{x}Run(list callback);n;globalParms;parms
      :Access Public Shared
    ⍝ Creates the GUI and hands over control to the user (modal call).\\
    ⍝ The result is a vector of Booleans representing the currently selected items.\\
    ⍝ You can assign something different to `n.∆result` in your own `onQuit` handler
    ⍝ within your callback; then this will be returned.
      (globalParms parms)←CreateParms GetParms{(0=⎕NC ⍵):'' ⋄ ⍎⍵}'x'
      n←globalParms parms Create list callback
      r←ModalWait n
    ∇

    ∇ n←{x}Create(list callback);∆;parms;globalParms;parmsMenubar
    ⍝ Takes two mandatory parameters:
    ⍝ * `list`  is a vector of text vectors (vtv). This is the list.
    ⍝ * `callback`  must be the name of a fully qualified function capable of processing
    ⍝   all the possible commands.
    ⍝
    ⍝   This callback might be triggered by a double-click, Control+Enter, clicking the
    ⍝   "Process" button, selecting the associated menu item from the menu bar or selecting
    ⍝   the associated menu item from the context menu.
    ⍝
    ⍝   It must be a monadic function that returns `⍬` as result.
    ⍝
    ⍝   The right argument comprises:
    ⍝   * Type. Is one of: "DblClick", "PushButton", "ContextMenu", "MenuItem".
    ⍝   * Vector of Booleans representing the selection or check box states.
    ⍝   * The `n` namespace.
    ⍝
    ⍝ `x` is optional and may contain zero, one or both of:
    ⍝ * `globalParms` see `#.AppleGuiParms.CreateDefaults`
    ⍝ * `parms` is typically created via `CreateParms`.
    ⍝
    ⍝    Returns a namespace with references to all the controls created. The
    ⍝    form lives as long as that namespace exists if no other refs were
    ⍝    created later.
    ⍝
    ⍝ Note that if you don't want a "Process" button then set
    ⍝ `parms.processBtnCaption←''`\\
    ⍝ Add a caption to `parms.menuItemCaptions` and/or `parms.contextMenuItemCaptions`.
    ⍝ Note that a menu "Command(s)" is added automatically if --- and only if --- `parms.menuItemCaptions`
    ⍝ is specified. The caption can be changed by setting `parms.menuCaption`.\\
    ⍝ Note also that `n.∆result` is preset to `⍬`. You can assign anything you want to `n.∆result`
    ⍝ from within the dedicated callback.
      :Access Public Shared
      'Selection array is empty?!'⎕SIGNAL 11/⍨0=≢list
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      (globalParms parms)←CreateParms GetParms x
      parms←CheckParms parms
      'Invalid: style'⎕SIGNAL APLGuiError/⍨~(⊂⎕C parms.style)∊##.Enums.SelectionStyles.⎕NL-3
      parms.contextMenuCaptions←PrepareContextMenu parms.contextMenuCaptions
      :If ↑parms.checkboxes
          parms.style←##.Enums.SelectionStyles.multi
      :EndIf
      n←##.StdForm.Create globalParms parms
      n.∆Form.⎕WS'Event'QuitEvent 1
      n.∆Form.onClose←'OnClose2'
      n.(∆result ∆handler)←⍬ callback
      n.∆data←parms.data
      parmsMenubar←##.Menubar.CreateParms
      parmsMenubar.debug←parms.debug
      n.menubar←##.Menubar.Create n.∆Form(GetListMenu n)parmsMenubar(⎕NEW ##.KeyCodes)
      n.menubar.⎕DF'[Menubar namespace]'
      :If 0<n.menubar.⎕NC'special'
          n.processCmds←{⍵⊣⍵.onSelect←'ExecHandler'}¨n.menubar.⍎¨'processCmd'{⍵/⍨((≢⍺)↑¨⍵)≡¨⊂⍺}'p'n.menubar.⎕NL-9
      :EndIf
      n(CreateInfo)←⊃parms.info
      n←CreateButtons n parms
      n.∆callback←n CheckCallback callback
      n.∆parms.onQuit←n CheckCallback n.∆parms.onQuit
      n(CreateList)←parms list
      {}n SelectItems parms.default
      :If ↑parms.dblClick
          n.List.onItemDblClick←'ExecHandler'
      :EndIf
      :If ↑0≠≢parms.contextMenuCaptions
          n.List.onContextMenu←'OnContextMenu'
      :EndIf
      ⎕NQ n.List RefreshEvent
      {}AdjustSizeAndPosn n
      n.∆Form ##.APLGuiHelpers.CenterIn globalParms.centerIn{0=≢⍵:⍺ ⋄ ⍵}parms.centerIn
      {}CheckPosition n.∆Form
     ⍝Done
    ∇

    ∇ r←CreateParms
      :Access Public Shared
    ⍝ Returns a parameter namespace with default settings.
      r←##.APLGuiParameterSpace.Create
      r.addToCaption←''
      r.alignButtons←##.Enums.Align.Left
      r.cancelBtnCaption←'Close'
      r.caption←''
      r.centerIn←''
      r.checkboxes←0
      r.colTitles←''
      r.contextMenuCaptions←''
      r.ctrlEnter←0
      r.data←⍬
      r.debug←1
      r.default←¯1   ⍝ Must be Boolean in the end
      r.dblClick←0
      r.(fontAPL fontInput fontLabel fontStandard)←⊂''
      r.hasStatusbar←1
      r.hasVersionField←0
      r.hGap←¯1
      r.icon←''
      r.info←''
      r.initialVgap←¯1
      r.maxButton←1
      r.menuCaption←'Command'
      r.menuItemCaptions←''
      r.minButton←1
      r.minSize←200 300
      r.noDevelopmentMenu←0
      r.onQuit←''
      r.parent←''
      r.parmType←'ProcessTool'
      r.posn←⍬ ⍬
      r.processBtnCaption←'Process'
      r.regKey2←''
      r.size←⍬ ⍬
      r.sizeable←1
      r.sortByCol←1
      r.statusbarMessage←''
      r.style←##.Enums.SelectionStyles.single
      r.sysMenu←1
      r.testMode←¯1
      r.timeout←0
      r.vGap←¯1
    ∇

    ∇ r←ModalWait n
    ⍝ Takes a ref pointing to a form created by this class.\\
    ⍝ Returns n.∆result
      :Access Public Shared
      {}⎕NQ n.List'GotFocus' ⋄ ⎕DQ n.∆Form
      r←n.∆result
      n.∆CloseForm
    ∇

⍝⍝⍝⍝ Private stuff

    ∇ {n}←CreateButtons(n parms)
      :If 0=≢parms.processBtnCaption
          n←##.StdForm.AddButtons(n(⊂'Cancel'))
          n.Btn_00.Caption←parms.cancelBtnCaption
          n.Btn_00.onSelect←'OnButtonPressed'
          n.Btn_00.Cancel←1
      :Else
          n←##.StdForm.AddButtons(n(parms.(processBtnCaption cancelBtnCaption)))
          n.Btn_00.Default←1
          :If 0≢parms.cancelBtnCaption
              n.Btn_01.onSelect←'OnButtonPressed'
              n.Btn_01.Cancel←1
          :EndIf
      :EndIf
      :If 2=≢n.∆buttons
          n.Btn_00.onSelect←'ExecHandler'
      :EndIf
    ∇

      OnKeyPressInList←{
    ⍝ ctrlEnter & checkboxes both come from n.∆parms but for performance
    ⍝ reasons must must go the dirt route here.
          (keys ctrlEnter checkboxes)←⍺
          _←⎕NQ(0⊃⍵)RefreshEvent
          (rf val key shiftState)←(6↑⍵,4⍴0)[0 2 4 5]
          keys CheckForControlEnter rf key shiftState ctrlEnter:
          ~key∊keys.all~keys.enter:1
          (key=keys.home):0⊣GoToHome rf shiftState
          (key=keys.end):0⊣GoToEnd rf shiftState
          (key=keys.blank):ToggleCurrentItem rf
          checkboxes:0=shiftState
          (key=keys.cursorUp):0⊣rf AddLines ¯1 shiftState
          (key=keys.cursorDown):0⊣rf AddLines 1 shiftState
          . ⍝ Huuh?!
      }

    ∇ r←n OnRefreshEvent msg;sh;no;rf
      ⍝ Refresh selection info in the status bar
      rf←n.List
      sh←≢rf.Items
      r←⍬
      :If rf.Style≡'Multi'
          :If n.∆parms.checkboxes
              no←+/GetSelection n
          :Else
              no←+/rf.SelItems
          :EndIf
          :If 0=no
              n.StatusField1.Text←'None of ',(⍕sh),' item',((1<sh)/'s'),' is selected'
          :ElseIf no=1
              n.StatusField1.Text←'1 item of ',(⍕sh),' is selected'
          :Else
              n.StatusField1.Text←(⍕no),' item',((1<no)/'s'),' of ',(⍕sh)
              n.StatusField1.Text,←((1<no)⊃,' is' ' are'),' selected'
          :EndIf
      :EndIf
    ∇

    ∇ n←n CreateList(parms list);∆;posn;_;ind
      ∆←''
      posn←(GetPosnOfList parms)
      ∆,←⊂'Posn'posn
      ∆,←⊂'Attach'('Top' 'Left' 'Bottom' 'Right')
      ∆,←⊂'GridLines' 1
      ∆,←⊂'FullRowSelect' 1
      ∆,←⊂'View' 'Report'
      :If 2=⍴⍴list
          ∆,←⊂'Items'(list[;0])
          ∆,←⊂'ReportInfo'(1↓[1]list,⊂'')
      :Else
          ∆,←⊂'Items'list
      :EndIf
      :If 0≠≢parms.colTitles
          ∆,←{(0≠≢⍵)/⊂'ColTitles'(⍵,⊂'')}parms.colTitles
      :Else
          ∆,←⊂'Header' 0
      :EndIf
      ∆,←⊂'Size'(CalcSizeOfListView n posn)
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←⊂'Style'parms.style
      ∆,←⊂'CheckBoxes'parms.checkboxes
      n.List←n.∆Form.⎕NEW'ListView'∆
      n.List.⎕DF'[ListView]:List'
      n.List.Event←RefreshEvent'OnRefreshEvent'n
      n.List.onKeyPress←'OnKeyPressInList'((GetSpecialKeys ⍬),parms.(ctrlEnter checkboxes))
      n.List.onItemUp←'OnItemUpInList'
      :If 2=⍴⍴list
          _←((0≠≢n.∆parms.colTitles)⊃¯2 ¯3){2 ⎕NQ n.List'SetColSize'⍵ ⍺}¨⍳1⊃⍴list  ⍝ Circumvent MS design bug.
          _←2 ⎕NQ n.List'SetColSize'(1⊃⍴list)0
      :Else
          _←2 ⎕NQ n.List'SetColSize' 0 ¯3
          _←2 ⎕NQ n.List'SetColSize' 0,(0=≢parms.colTitles)⊃¯3 ¯2  ⍝ Circumvent MS design bug.
          _←2 ⎕NQ n.List'SetColSize' 1 1
      :EndIf
      n.menubar.adjustHeight.onSelect←'OnAdjustHeight'n
      :If parms.sortByCol
          n.List.onColumnClick←'OnColumnClick'
          n.List.∆orderedBy←¯1 0  ⍝ [0]=Column no, [2]=sort direction: 1 is up, ¯1 is down
      :EndIf
      :If GetMultipleFlag parms
          n.menubar.selectAll.onSelect←'OnSelectAll'n
          n.menubar.selectNone.onSelect←'OnSelectNone'n
          n.menubar.invertSelection.onSelect←'OnInvertSelection'n
      :EndIf
      n.∆origOrder←⍳0⊃⍴list
    ∇

    ∇ r←CheckUserCallback n;parent;fns
      :If 0=≢n.∆parms.onQuit
          r←1
      :Else
          parent←↑n.∆parms.onQuit
          fns←parent⍎1⊃n.∆parms.onQuit
          :If 0=↑↑⎕AT'fns'  ⍝ No result?
              fns n
              r←1
          :Else
              r←fns n
          :EndIf
      :EndIf
    ∇

    ∇ r←GoToHome(rf ss);_;b;f;sh;ci
      r←⍬
      f←NeedsSelectionToBeEnhanced rf ss
      sh←≢rf.Items
      :If f
          rf.SelItems∨←sh↑(GetCurrentItemNo rf)⍴1
      :Else
          _←rf.SelItems{⍵↑⍨≢⍺}←1
      :EndIf
      {}SetFocusTo rf 0
    ∇

    ∇ r←GoToEnd(rf ss);_;f;sh;ci;b;ind
      r←⍬
      f←NeedsSelectionToBeEnhanced rf ss
      sh←≢rf.Items
      :If f
          rf.SelItems←~sh↑(GetCurrentItemNo rf)⍴1
      :Else
          _←rf.SelItems{⍵↑⍨-≢⍺}←1
      :EndIf
      {}SetFocusTo rf(sh-1)
    ∇

    ∇ {r}←rf AddLines(ci ss);f;in;sh;new;b;state;_      ⍝ Current Item, Shift State
    ⍝ rf points to the ListView control
      r←⍬
      f←NeedsSelectionToBeEnhanced rf ss                ⍝ Flag: does current selection need to be extended?
      in←GetCurrentItemNo rf                            ⍝ Item number
      sh←≢rf.Items
      new←(0+¯1=ci)⌈(sh-1+1=ci)⌊in
      b←rf GetItemState new
      _←2 ⎕NQ rf'SetItemState'(new)(Power2 b)           ⍝ Change state; con't call method: bug 10925
      b←rf GetItemState new+ci
      b[0]←1                                            ⍝ Set Focus
      _←2 ⎕NQ rf'SetItemState'(new+ci)(Power2 b)        ⍝ Don't call the method: bug 10925
      :If f
          rf.SelItems[new+ci,0]←1
      :Else
          rf.SelItems←sh⍴0
          rf.SelItems[new+ci]←1
          {}SetFocusTo rf(new+ci)
      :EndIf
    ∇

    GetMultipleFlag←{parms←⍵ ⋄ 'multi'≡parms.style}

    ∇ r←GetListMenu n;this;multipleFlag;i;cb
      multipleFlag←GetMultipleFlag n.∆parms
      r←''
      r,←⊂'[Edit]                       {edit}'
      this←⍕⎕THIS
     ⍝r,←⊂' Copy list=Ctrl+C            {copyList}          ;Copies the complete list'
     ⍝r,←⊂' ~Copy table=Ctrl+Shift+C    {copyTable}         ;Copies the complete table'
      :If multipleFlag
          r,←⊂' Select all=Ctrl+A           {selectAll}         ;Select all items'
          r,←⊂' Select none=Ctrl+N          {selectNone}        ;De-select all items'
          r,←⊂' Invert selection=Ctrl+I     {invertSelection}   ;Invert the selection'
          r,←⊂' -'
      :EndIf
      r,←⊂' Adjust height=F8            {adjustHeight}      ;Enlarges the form to what''s needed'
      :If 0≠≢n.∆parms.menuItemCaptions
          r,←⊂'[',n.∆parms.menuCaption,']      {special}'
          n.∆parms.menuItemCaptions←⊂∘,⍣(2>≡n.∆parms.menuItemCaptions)⊣n.∆parms.menuItemCaptions
          :For i :In ⍳≢,n.∆parms.menuItemCaptions
              this←i⊃,n.∆parms.menuItemCaptions
              r,←⊂' ',this,' {processCmd',(⍕i),'}'
          :EndFor
      :EndIf
      :If n.∆parms.debug
      :AndIf 0=n.∆parms.noDevelopmentMenu
          r,←⊂'[Developers]'
          cb←(⍕⎕THIS),'.OnEditCallback'
          r,←⊂' Edit callback  :',cb,'  {editCallback}      ;Only available in development mode'
      :EndIf
    ∇

      NeedsSelectionToBeEnhanced←{
     ⍝ Returns flag, 1 meaning that the current selection needs extension
          (rf ss)←⍵             ⍝ Ref to ListView, Shift State
          (1≠ss):0
          rf.Style≡'Multi'
      }

    ∇ r←OnButtonPressed msg;n
      n←GetRefTo_n↑msg
      n.∆buttonPressed←↑msg
      n.∆result←GetSelection n
      :If r←CheckUserCallback n
          ⎕NQ n.∆Form QuitEvent
      :EndIf
    ∇

      OnContextMenu←{
          n←GetRefTo_n 0⊃⍵
          0=≢n.∆parms.contextMenuCaptions:0
          m←n.∆Form.⎕NEW⊂'Menu'
          cancel←m.⎕NEW'MenuItem'(⊂('Caption' 'Cancel'))
          _←cancel.⎕DF'[MenuItem]:cancel'
          cancel.onSelect←1
          s←m.⎕NEW⊂'Separator'
          cmds←m{⍺.⎕NEW'MenuItem'(⊂'Caption'⍵)}¨n.∆parms.contextMenuCaptions
          _←{⍵.onSelect←'ExecHandler'}EnPassant¨cmds
          0⊣⎕DQ m
      }

    ∇ {r}←ExecHandler msg;n;type;f;caption
      n←GetRefTo_n 0⊃msg
      :If 'ItemDblClick'≡1⊃msg
          n CorrectSelectionAfterDblClick 2⊃msg
          type←'DblClick'
      :ElseIf n.Btn_00≡0⊃msg
          type←'PushButton'
      :ElseIf (⊂{⍵.Caption}0⊃msg)∊n.∆parms.contextMenuCaptions
          type←'ContextMenu'
          caption←(0⊃msg).Caption
      :ElseIf 0<n.⎕NC'processCmds'
      :AndIf ∨/(0⊃msg)⍷n.processCmds
          type←'MenuItem'
          caption←(0⊃msg).Caption
      :Else
          . ⍝ Huuh?!
      :EndIf
      :If 0=⎕NC'caption'
          r←ExecHandler_ n type
      :Else
          r←caption ExecHandler_ n type
      :EndIf
    ∇

    ∇ {r}←{caption}ExecHandler_(n type);fns
      :If 2=≡n.∆callback
          fns←(0⊃n.∆callback).⍎1⊃n.∆callback
      :Else
          fns←⍎n.∆callback
      :EndIf
      :If 0=⎕NC'caption'
          r←fns type(GetSelection n)n
      :Else
          r←caption fns type(GetSelection n)n
      :EndIf
    ∇

      CorrectSelectionAfterDblClick←{
          n←⍺
          in←⍵       ⍝ Item number
          n.List.SelItems[]←0
          n.List.SelItems[in]←1
      }

      CheckForControlEnter←{
      ⍝ ctrlEnter comes from n.∆parms.ctrlEnter; performance!
          keys←⍺
          (rf key shift ctrlEnter)←⍵
          n←GetRefTo_n rf
          (keys.enter≠key)∨2≠shift:0           ⍝ No <Ctrl+Enter>? Done?
          (0=ctrlEnter):1
          1⊣ExecHandler_ n'Ctrl+Enter'
      }

      PrepareContextMenu←{
      ⍝ Leave alone when empty or nested but enclose otherwise.
          0=≢cm←⍵:⍵               ⍝ context menu caption(s):cm
          ,⊂∘,⍣(2>≡cm)⊣cm
      }

    ∇ {r}←OnEditCallback msg;n;callback
      :Access Public Shared
      r←0
      n←GetRefTo_n↑msg
      :If 0<(↑n.∆callback).⎕NC 1⊃n.∆callback
          :If 14.1≤⍎{⍵/⍨2>+\'.'=⍵}1⊃'#'⎕WG'APLVersion'
              ((↑n.∆callback).⎕ED⍠('EditName' 'Allow'))1⊃n.∆callback
          :Else
              (↑n.∆callback).⎕ED 1⊃n.∆callback  ⍝ Prior the version 14.1 we can just edit this one
          :EndIf
      :Else
          msg←'The callback:'('  ',(⍕↑n.∆callback),'.',1⊃n.∆callback)'does not yet exist'
          msg,←'' 'Would you like to create a stub? You can then execute "Edit callback" again.'
          :If n.∆globalParms ##.Dialogs.YesOrNo msg
              (↑n.∆callback).⎕FX('{r}←{caption}',(1⊃n.∆callback),' (eventType selected n)')'r←⍬' '⍝TODO⍝' '⎕←(eventType selected n)'
          :EndIf
      :EndIf
    ∇

    ∇ r←OnClose2 msg;n
      n←##.APLGuiUtils.GetRefTo_n 0⊃msg
      n.∆result←GetSelection n
      :If 0=≢n.∆parms.onQuit
          r←1
      :Else
          r←CheckUserCallback n
      :EndIf
      :If r
          {}##.APLGuiHelpers.SavePosnAndSizeInRegistry n
          n.∆Form.∆closed←1
      :EndIf
    ∇

:EndClass

