:Class Notepad
⍝ Simple text editor. Appropriate for relatively small portions of text.\\
⍝ Not designed to write books!
⍝
⍝ There are four modal methods available: `Edit`, `EditFile`, `Browse` and `BrowseFile`.
⍝
⍝ Note that by default it's an ordinary editor. In particular
⍝ the classic Windows key for cut/copy/paste are supported
⍝ (Shift+Del, Ctrl+Ins, Shift+Insert) as well as the Macintosh-style
⍝ keyboard shortcuts (Ctrl+X/C/V).
⍝
⍝ By setting the parameter `aplMode` to 1 you can force `Edit`
⍝ to use the "APL385 Unicode" font.
⍝
⍝ Author: Kai Jaeger ⋄ Copyright: APL Team Ltd

    :Include APLGuiUtils

    ⎕IO←0 ⋄ ⎕ML←3

    :Field Public Shared ReadOnly RefreshEvent←9999
    :Field Public Shared ReadOnly QuitEvent←9998
    :Field Public Shared ReadOnly CheckForChangeEvent←9997

    ∇ r←ListHelpers
      :Access Public Shared
      r←'Edit' 'EditFile' 'Browse' 'BrowseFile'
    ∇

    ∇ (text changeFlag)←{x}Edit VTV;n;x;globalParms;parms;⎕TRAP;defaultParms
      :Access Public Shared
    ⍝ Creates the GUI and returns the `n` namespace
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      defaultParms←CreateParms
      (globalParms parms)←defaultParms GetParms x
      n←(globalParms parms)Create VTV defaultParms
      (text changeFlag)←ModalWait n
    ∇

    ∇ changeFlag←{x}EditFile filename;n;x;globalParms;parms;⎕TRAP;defaults
      :Access Public Shared
    ⍝ Creates the GUI & hands over control to the user (modal call).\\
    ⍝ `changeFlag` indicates whether the text got changed or not.\\
    ⍝ In case `hasMenuItem_Open` is 1 then `filename` should be empty and vice versa.
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      defaults←CreateParmsForFile
      (globalParms parms)←defaults GetParms x
      parms←CheckParmsConsistency parms filename
      parms.askForSave∨←parms.(∨/hasMenuItem_Save hasMenuItem_SaveAs)
      n←globalParms parms CreateForEditFile filename
      n.∆filename←filename
      changeFlag←1↓ModalWait n
    ∇

    ∇ {r}←{x}Browse VTV;⎕TRAP;defaultParms;globalParms;parms;n
      :Access Public Shared
    ⍝ Creates the GUI & hands over control to the user.\\
    ⍝ The user can scroll and copy but nothing else.\\
    ⍝ Returns always ⍬.
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      r←⍬
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      defaultParms←CreateParms
      (globalParms parms)←defaultParms GetParms x
      :If parms.aplMode
          :If 0=≢,parms.fontAPL
              parms.fontAPL←⎕NEW'Font'(('PName' 'APL385 Unicode')('Size' 20))
              parms.fontInput←parms.fontAPL
          :Else
              parms.fontInput←parms.fontAPL
          :EndIf
      :EndIf
      parms.readOnly←1
      parms.hasMenuItem_Restore←0
      parms.onFileSaveAs←''
      n←(globalParms parms)CreateBrowse VTV
      {}ModalWait n
    ∇

    ∇ {dummy}←{x}BrowseFile filename;n;_;x;globalParms;parms;⎕TRAP
      :Access Public Shared
    ⍝ Creates the GUI, load `filname` into it & hands over control to the user.\\
    ⍝ The user can scroll and copy but nothing else.
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      dummy←⍬
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      (globalParms parms)←CreateParmsForFile GetParms x
      parms.readOnly←1
      parms.hasMenuItem_Restore←0
      parms.∆filename←filename
      n←(globalParms parms)CreateForEditFile filename
      _←ModalWait n
    ∇

    ∇ n←{x}CreateBrowse text;globalParms;parms;defaultParms
      :Access Public Shared
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      defaultParms←CreateParms
      (globalParms parms)←defaultParms GetParms x
      :If parms.aplMode
          parms.fontInput←parms.fontAPL
      :EndIf
      parms.readOnly←1
      parms.hasMenuItem_Restore←0
      parms.onFileSaveAs←''
      n←globalParms parms Create text defaultParms
    ∇

    ∇ n←{globalParms}Create(vtv defaultParms);∆;globalParms;parms;rk;v;⎕TRAP;parms2;menu
    ⍝ Takes two mandatory parameter:
    ⍝ * `vtv` is a Vector of Text Vectors or a simple string.
    ⍝ * `defaultParms` is the result of something like `CreateParms`.
    ⍝
    ⍝ `x` is optional and may contain zero, one or both of:
    ⍝ * For `globalParms` see `#.GUI.APLGuiGlobalParms.CreateDefaults.`
    ⍝ * For `parms` is typically created via `CreateParms`.
    ⍝
    ⍝ Returns a namespace with references to all the controls created.
    ⍝ The form lives as long as that namespace exists if no other refs
    ⍝ were created later on.
      :Access Public Shared
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      parms←CreateParms
      (globalParms parms)←defaultParms GetParms globalParms
      parms2←CopyNamespace parms
      parms2.onClose←''
      parms2.(sysMenu maxButton minButton sizeable)←1
      parms2.parmType←'StdForm'
      parms2.initialVgap←0
      n←##.StdForm.Create globalParms parms2
      parms2.onClose←parms{0=⍺.⎕NC ⍵:'' ⋄ ⍺.⍎⍵}'onClose'
      n.∆Form.onClose←'OnQuit'
      n.∆askForSave←parms.askForSave       ⍝ Honoured by OnQuit
      parms2.(onClose onInitial)←n CheckCallback¨parms2.(onClose onInitial)
      menu←GetMenus parms''
      n.menubar←##.Menubar.Create n.∆Form menu ⍬(⎕NEW ##.KeyCodes)
      n.menubar.⎕DF'[Menubar namespace]'
      n.∆parms.(fontInput fontLabel fontStandard)←parms.(fontInput fontLabel fontStandard)
      n.FontObj←globalParms CreateFont n
      n.Edit←CreateEdit n n.∆Form vtv
      :If 0<n.∆parms.⎕NC'fontInput'
      :AndIf 1<≢n.∆parms.fontInput
          AddFontMenu n
      :EndIf
      n.∆changeFlag←0
      n.∆result←vtv
      :If 0=parms.readOnly
          n.∆originalText←n.Edit.Text
      :EndIf
      n.∆Form ##.APLGuiHelpers.CenterIn globalParms.centerIn{0=≢⍵:⍺ ⋄ ⍵}parms.centerIn
      {}CheckPosition n.∆Form
      {}ExecuteOnInitial n
      n←InitialFindVars n
      n←InitialUndoRedoStack n n.Edit.Text
     ⍝Done
    ∇

    ∇ n←{x}CreateForEditFile filename;∆;globalParms;parms;rk;v;⎕TRAP;parms2
    ⍝ `x` must be a vector of length two with `parms` and `globalParms`.\\
    ⍝ Parameters are typically created by calling `CreateParmsForFile`.
    ⍝ Returns a namespace with references to all the controls created.
    ⍝ The form lives as long as that namespace exists if no other refs
    ⍝ were created later on.
      :Access Public Shared
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      (globalParms parms)←CreateParmsForFile GetParms x
      parms2←CopyNamespace parms
      parms2.onClose←''
      parms2.(sysMenu maxButton minButton sizeable)←1
      parms2.parmType←'StdForm'
      parms2.initialVgap←¯1
      n←##.StdForm.Create globalParms parms2
      parms2.onClose←parms{0=⍺.⎕NC ⍵:'' ⋄ ⍺.⍎⍵}'onClose'
      n.∆Form.onClose←'OnQuit'
      n.∆askForSave←parms.askForSave       ⍝ Honoured by OnQuit
      parms2.(onClose onFileOpen onFileSaveAs onInitial)←n CheckCallback¨parms2.(onClose onFileOpen onFileSaveAs onInitial)
      n.menubar←##.Menubar.Create n.∆Form(GetMenus parms filename)⍬(⎕NEW ##.KeyCodes)
      n.menubar.⎕DF'[Menubar namespace]'
      n.∆parms.(fontInput fontLabel fontStandard)←parms.(fontInput fontLabel fontStandard)
      n.FontObj←globalParms CreateFont n
      n.Edit←CreateEdit n n.∆Form''
      n.∆changeFlag←0
      :If 0=parms.readOnly
          n.∆originalText←n.Edit.Text
      :EndIf
      n.∆Form ##.APLGuiHelpers.CenterIn globalParms.centerIn{0=≢⍵:⍺ ⋄ ⍵}parms.centerIn
      {}CheckPosition n.∆Form
      {}LoadFileIntoEdit⍣(↑0≠≢filename)⊣n filename
      {}ExecuteOnInitial n
      n←InitialFindVars n
      n←InitialUndoRedoStack n n.Edit.Text
     ⍝Done
    ∇

    ∇ r←CreateParms
      :Access Public Shared
    ⍝ Returns a parameter namespace with default settings for being fed to `Edit`.
      r←##.APLGuiParameterSpace.Create
      r.addToCaption←''                         ⍝
      r.aplMode←0
      r.askForSave←0
      r.caption←''                              ⍝
      r.centerIn←''
      r.cmdMenu←''
      r.(fontAPL fontLabel fontStandard)←⊂''
      r.fontInput←¯1
      r.hasMenuItem_Restore←1
      r.hasProgressbar←0                        ⍝
      r.hasStatusbar←1                          ⍝
      r.hasVersionField←1                       ⍝
      r.icon←''                                 ⍝
      r.minSize←(⍬ ⍬)                           ⍝
      r.onInitial←''
      r.parmType←'Notepad'
      r.parent←''
      r.posn←(⍬ ⍬)                              ⍝
      r.readOnly←0
      r.regKey2←¯1                              ⍝
      r.size←(⍬ ⍬)                              ⍝
      r.statusbarMessage←''                     ⍝
      r.undoRedoBufferLength←500
      ⍝Done
    ∇

    ∇ r←CreateParmsForFile
      :Access Public Shared
    ⍝ Returns a parameter namespace with default settings for being fed to `EditFile` and `BrowseFile`.
      r←CreateParms
      r.askForSave←1
      r.hasMenuItem_Save←1
      r.hasMenuItem_SaveAs←0
      r.hasMenuItem_Open←0
      r.hasMenuItem_Restore←1
      r.onFileOpen←(↑↑⎕CLASS ⎕THIS)'OnFileOpen'
      r.onFileSaveAs←''
      r.parmType←'Notepad.EditFile'
      ⍝Done
    ∇

    ∇ r←GetSelection(text selText)
    ⍝ Returns the text that is currently selected in the Edit control.
      :Access Public Shared
      :If ≡/↑¨selText                        ⍝ Simple?!
          r←(-/⌽1⊃¨selText)↑(¯1+0 1⊃selText)↓(¯1+0 0⊃selText)⊃text
      :Else
          r←(¯1+0 0⊃selText)↓text
          r←(1+-/⌽0⊃¨selText)↑r
          (0⊃r)←(¯1+0 1⊃selText)↓0⊃r
          ((¯1+≢r)⊃r)←(¯1+1 1⊃selText)↑(¯1+≢r)⊃r
      :EndIf
    ∇

    ∇ OnFind msg;n
      :Access Public Shared
      n←GetRefTo_n↑msg
      FindInText n
    ∇

    ∇ OnNextHit msg;n;selText;tx;searchedFor;col;line
      :Access Public Shared
      n←GetRefTo_n↑msg
      :If (≢n.∆Hits)=n.∆Ind←1+n.∆Ind
          n.∆Ind←0
      :EndIf
      (line col)←n.∆Ind⊃n.∆Hits
      selText←(1+line),¨(1(1+≢n.∆LastSearchString))+col
      tx←(-/⌽1⊃¨selText)↑(¯1+0 1⊃selText)⌽(¯1+↑↑selText)⊃n.Edit.Text
      tx←⎕C⍣(~n.∆MatchCase)⊣tx
      searchedFor←⎕C⍣n.∆MatchCase⊣n.∆LastSearchString
      :If tx≡searchedFor
          n.Edit.SelText←selText
          n.StatusField1.Text←'Text "',n.∆LastSearchString,'" found ',(⍕{+/0<≢¨⍵}n.∆Hits),' times. -',(⍕1+n.∆Ind),'- is highlighted.'
      :Else
          n.StatusField1.Text←''
          n.menubar.nextHit.Active←0
          n.(∆Ind ∆Hits)←⊂⍬
      :EndIf
    ∇

    ∇ r←GetMenus(parms filename)
      :Access Public Shared
      r←GetFileMenu parms filename
      r,←GetEditMenu parms filename
    ∇

    ∇ r←CreateEdit(n parent txt);∆;_;ind
      :Access Public Shared
      :If 0=n.∆parms.⎕NC'FontInput'
          n.FontObj←↑n.∆parms.fontInput
      :EndIf
      ∆←''
      ∆,←⊂'Coord' 'Prop'
      ∆,←⊂'Posn'(0 0)
      ∆,←⊂'Size'(100 100)
      ∆,←⊂'Attach'('Top' 'Left' 'Bottom' 'Right')
      ∆,←⊂'Text'txt
      ∆,←⊂'Style' 'Multi'
      ∆,←⊂'ReadOnly'n.∆parms.readOnly
      ∆,←⊂'FontObj'n.FontObj
      ∆,←⊂'WantsReturn' 1
      ∆,←⊂'VScroll' ¯1
      :If n.∆parms.aplMode
      :AndIf 0=n.∆parms.readOnly
          ∆,←⊂'BCol'(0 0 0)
          ∆,←⊂'FCol'(255 255 0)
      :EndIf
      r←parent.⎕NEW'Edit'∆
      r.⎕DF'[Edit]:',⍕parent
      ⍎'r.on',(⍕CheckForChangeEvent),'←''OnCheckForChange'''
      r.onKeyPress←'OnKeyPressInEdit'
      r.Coord←'Pixel'
      :If 'Form'≡parent.Type ⍝ SubForms have no status bar
          r.Size[0]-←parent.n.Statusbar.Size[0]
      :EndIf
      :If n.∆parms.readOnly
          r.BCol←¯1
      :EndIf
    ∇

    ∇ {r}←OnSelectAll msg;n
      :Access Public Shared
      n←GetRefTo_n↑msg
      n.Edit.SelText←(0 0)((≢n.Edit.Text),({1+≢⍵⊃⍨¯1+≢⍵}n.Edit.Text))
    ∇

    ∇ r←globalParms CreateFont n
      :If 0=≢n.∆parms.fontInput
          :If n.∆parms.aplMode
              r←globalParms.fontAPL
          :Else
              r←globalParms.fontInput
          :EndIf
      :ElseIf ¯1≡n.∆parms.fontInput
          :If n.∆parms.aplMode
              n.∆parms.fontInput←⎕NEW'Font'(('PName' 'APL385 Unicode')('Size' 20))
              n.∆parms.fontInput,←⎕NEW'Font'(('PName' 'Verdana')('Size' 20))
              r←n.∆parms.fontInput
          :Else
              r←n.∆parms.fontInput←⎕NEW'Font'(('PName' 'Verdana')('Size' 20))
          :EndIf
      :Else
          r←n.∆parms.fontInput
      :EndIf
    ∇

    ∇ OnUserDefinedMenuItem msg;n;fns;caption;ind
      :Access Public Shared
      n←GetRefTo_n↑msg
      caption←{⍵↑⍨⍵⍳⎕UCS 9}(↑msg).Caption
      ind←1⍳⍨caption{⍺∘≡¨(≢⍺)↑¨⍵}{⍵[;0]~¨⊂'~&'}⊃1↓n.∆parms.cmdMenu
      fns←⍎1⊃ind⊃1↓parms.cmdMenu
      {}fns n caption
    ∇

    ∇ {r}←OnCutInAplMode msg
      :Access Public Shared
    ⍝ This callback translates <Shift+Del> into <CT>
      r←1⊣'CT'SendKeyToEdit 0⊃msg
      ⎕NQ n.Edit CheckForChangeEvent
    ∇

    ∇ {r}←OnCopyInAplMode msg
      :Access Public Shared
    ⍝ This callback translates <Ctrl+Ins> into <CP>
      r←1⊣'CP'SendKeyToEdit 0⊃msg
    ∇

    ∇ {r}←OnPasteInAplMode msg
      :Access Public Shared
    ⍝ This callback translates <Shift+Ins> into <PT>
      r←1⊣'PT'SendKeyToEdit 0⊃msg
      ⎕NQ n.Edit CheckForChangeEvent
    ∇

    ∇ {r}←OnCut msg;rf;n
      :Access Public Shared
    ⍝ This callback translates <Shift+Del> into <Ctrl+X>
      rf←↑msg
      r←1⊣'CT'SendKeyToEdit rf
      n←GetRefTo_n rf
      ⎕NQ n.Edit CheckForChangeEvent
    ∇

    ∇ OnInitialFind n
      :Access Public Shared
      n.MatchCase.Posn←n.∆Vgap+↑↑+⌿n.SearchFor.(Posn Size)
      n.MatchWord.Posn←n.∆Vgap+↑↑+⌿n.MatchCase.(Posn Size)
      n.Start.Posn[0]←n.∆Vgap+↑↑+⌿n.SearchFor.(Posn Size)
      n.Start.Posn[1]←(1⊃+⌿⊃n.SearchFor.(Posn Size))-n.Start.Size[1]+3
    ∇

    ∇ {r}←OnCopy msg
      :Access Public Shared
    ⍝ This callback translates <Ctrl+Ins> into <Ctrl+C>
      r←1⊣'CP'SendKeyToEdit 0⊃msg
    ∇

    ∇ {r}←OnPaste msg;n
      :Access Public Shared
    ⍝ This callback translates <Shift+Ins> into <Ctrl+V>
      r←1⊣'PT'SendKeyToEdit 0⊃msg
      n←GetRefTo_n 0⊃msg
      ⎕NQ n.Edit CheckForChangeEvent
    ∇

    ∇ r←OnKeyPressInEdit msg;where;buffer;n
      :Access Public Shared
      n←GetRefTo_n 0⊃msg
      :If 'HT'≡2⊃msg
          r←0
      :AndIf ≡/n.Edit.SelText
          where←¯1+↑n.Edit.SelText
          buffer←where[0]⊃n.Edit.Text
          buffer←(-where[1])⌽(4⍴' '),where[1]⌽buffer
          (where[0]⊃n.Edit.Text)←buffer
          n.Edit.SelText←2⍴⊂{⍵[0],4+1⊃⍵}1+where
      :EndIf
      ⎕NQ n.Edit CheckForChangeEvent
    ∇

    ∇ r←OnDelete msg;rf
      :Access Public Shared
    ⍝ Deal with the "Del" key
      rf←GetRefTo_n 0⊃msg
      ⎕NQ rf.Edit'KeyPress' 'DI'
      ⎕NQ n.Edit CheckForChangeEvent
    ∇

    ∇ r←OnOpen msg;n
      :Access Public Shared
      n←GetRefTo_n 0⊃msg
      r←ExecHandler n'Open'
    ∇

    ∇ r←OnFileOpen n;filename;n
      :Access Public Shared
      r←⍬
      :If 0≠≢n.∆filename←OpenFileDialogBox n
          n.Edit.Text←⊃⎕NGET n.∆filename
          n.∆originalText←n.Edit.Text
          n.menubar.open.Active←0
          n.menubar.save.Active←1
      :EndIf
    ∇

    ∇ filename←OpenFileDialogBox n;∆;ref;res
      :Access Public Shared
      ⍝{}SelfBaseParent.FileBox.OpenFileDialogBox n
      filename←''
      ∆←⊂''
      ∆,←⊂'Caption'n.∆Form.Caption
      ⍝ref←n.∆Form.⎕NEW'FileBox'∆
      ref←n.∆Form.⎕NEW⊂'FileBox'
      ref.Caption←n.∆Form.Caption,': Open File'
      ref.(onFileBoxOK onFileBoxCancel)←1
      res←ref.Wait
      filename←ref.{↑{⍺,⍵}/Directory File}⍣(↑'FileBoxOK'≡1⊃res)⊣⍬
    ∇

    ∇ r←OnSave msg;fns;n;newText
      :Access Public Shared
      n←GetRefTo_n 0⊃msg
      :If n.∆originalText≢newText←n.Edit.Text
          (⊂,newText)⎕NPUT n.∆filename 1
          n.∆originalText←n.Edit.Text
      :EndIf
    ∇

    ∇ r←OnSaveAs msg;fns;n
      :Access Public Shared
      n←GetRefTo_n 0⊃msg
      r←ExecHandler n'SaveAs'
      n.∆originalText←n.Edit.Text
    ∇

    ∇ {r}←ExecHandler(n name);parent;name;fns
      (parent name)←{2=≡⍵:⍵ ⋄ ⎕THIS ⍵}n.∆parms.⍎'onFile',name
      fns←parent⍎name
      r←fns n
    ∇

    ∇ r←OnRestoreText msg;rf
      :Access Public Shared
      rf←GetRefTo_n 0⊃msg
      rf.∆result←rf.Edit.Text←rf.∆originalText
      ⎕NQ n.Edit CheckForChangeEvent
      r←1
    ∇

    ∇ r←OnQuit msg;n
      :Access Public Shared
      n←GetRefTo_n 0⊃msg
      {}SavePosnAndSize n
      :If 0<n.⎕NC'Edit'
          r←HandleQuitInEditMode n
      :Else
          r←1
          n.∆changeFlag←0
          n.∆CloseForm
          n.∆Form.∆closed←1
      :EndIf
    ∇

    ∇ n←InitialUndoRedoStack(n text)
      :Access Public Shared
      n.∆LastSelText←0 0
      n.∆Commit←(⎕NS'')UndoRedo
      '!'n.∆Commit 0
      n.∆Commit n.∆LastSelText text
    ∇

    ∇ n←InitialFindVars n
      :Access Public Shared
      n.∆LastSearchString←''
      n.(∆MatchCase ∆MatchWord)←0
      n.∆Hits←⍬
      n.∆ind←⍬  ⍝ If not empty this points into ∆Hits (for "Next hit")
    ∇

    :Section PrivateStuff

      OnKeyPressInList←{
          _←⎕NQ(0⊃⍵)RefreshEvent
          (rf key shiftState)←⍵[0 4 5]
          (~key∊36 38 35 40 32):1  ⍝ Not up,down,home,end, blank?!
          (key=36):0⊣GoToHome rf shiftState
          (key=35):0⊣GoToEnd rf shiftState
          (key=38):0⊣rf AddLines ¯1 shiftState
          (key=40):0⊣rf AddLines 1 shiftState
          (key=32):ToggleCurrentItem rf
          . ⍝ Huuh?!
      }

    ∇ OnUndo msg;n;buff
      :Access Public Shared
      n←GetRefTo_n↑msg
      buff←'<'n.∆Commit n.Edit.SelText n.Edit.Text
      n.Edit.Text←1⊃buff        ⍝ First Text...
      n.Edit.SelText←↑buff      ⍝ ... then SelText!
      n.menubar.(redo undo).Active←0<'?'n.∆Commit 0
    ∇

    ∇ OnRedo msg;n
      :Access Public Shared
      n←GetRefTo_n↑msg
      n.Edit.(SelText Text)←'>'n.∆Commit n.Edit.SelText n.Edit.Text
      n.menubar.(redo undo).Active←0<'?'n.∆Commit 0
    ∇

    ∇ r←GetFileMenu(parms filename);Quit;emptyFlag;flag;this;i
      r←⊂'[File]                                           {file}'
      flag←0
      :If 0<parms.⎕NC'hasMenuItem_Open'
      :AndIf parms.hasMenuItem_Open
          r,←⊂' Open=Ctrl+O             : OnOpen            {open}      ;Open a file for editing'
          flag←1
      :EndIf
      :If 0<parms.⎕NC'hasMenuItem_Save'
      :AndIf parms.hasMenuItem_Save
          emptyFlag←0=≢filename
          r,←⊂' ',(emptyFlag/'~'),'Save=Ctrl+S : OnSave     {save}      ;Save changes to file'
          flag←1
      :EndIf
      :If 0<parms.⎕NC'hasMenuItem_SaveAs'
      :AndIf parms.hasMenuItem_SaveAs
          r,←⊂' Save as...=Ctrl+Shift+S : OnSaveAs          {saveAs}    ;Save changes to another file'
          flag←1
      :EndIf
      r,←flag/⊂' -'
      r,←⊂' Quit=Alt+F4                 : OnQuit            {quit}      ;Quit the program'
      :If 0≠≢parms.cmdMenu
          r,←⊂'[',(↑parms.cmdMenu),']                                           {cmd}'
          :For i :In 1+⍳≢1↓parms.cmdMenu
              this←i⊃parms.cmdMenu
              :If (,'-')≡,this
                  r,←⊂' Separator : {sep',(⍕i),'}'
              :Else
                  :If 3≠⎕NC 1⊃this
                      6 ⎕SIGNAL⍨'Cannot see callback for user-defined menu item ',⍕i
                  :Else
                      r,←⊂(' ',##.APLTreeUtils2.DLB'~'~⍨↑this),'  : OnUserDefinedMenuItem {cmd_',(⍕¯2↑'00',⍕i),'}'
                  :EndIf
              :EndIf
          :EndFor
      :EndIf
    ∇

    ∇ r←GetEditMenu(parms filename)
      r←⊂'[Edit]                                           {edit}'
      :If 0=parms.readOnly
      :AndIf parms.undoRedoBufferLength>0
          r,←⊂' ~Undo=Ctrl+Z            : OnUndo        {undo}      ;Undo the latest change'
          r,←⊂' ~Redo=Ctrl+Y            : OnRedo        {redo}      ;Redo the latest undo'
          r,←⊂' -'
      :EndIf
      :If parms.aplMode
          r,←(0=parms.readOnly)/⊂' Cut=Shift+Del           : OnCutInAplMode    {cut}       ;Copies selected text and also deletes it from the text'
          r,←⊂' Copy=Ctrl+Ins           : OnCopyInAplMode   {copy}      ;Copies selected text'
          r,←(0=parms.readOnly)/⊂' Paste=Shift+Ins         : OnPasteInAplMode  {paste}     ;Paste clipboard'
          r,←(0=parms.readOnly)/⊂' Delete=Del              : OnDelete          {del}       ;Deletes selected text'
          r,←⊂' Select all=Shift+Ctrl+A : OnSelectAll       {selectAll} ;Selects the text'
      :Else
          r,←(0=parms.readOnly)/⊂' Cut=Ctrl+X              : OnCut             {cut}       ;Copies selected text'
          r,←⊂' Copy=Ctrl+C             : OnCopy            {copy}      ;Copies selected text or everything if there is no selection'
          r,←(0=parms.readOnly)/⊂' Paste=Ctrl+V            : OnPaste           {paste}     ;Paste clipboard'
          r,←(0=parms.readOnly)/⊂' Delete=Del              : OnDelete          {del}       ;Deletes selected text'
          r,←⊂' Select all=Ctrl+A       : OnSelectAll       {selectAll} ;Selects the text'
      :EndIf
      r,←⊂' -'
      :If parms.hasMenuItem_Restore
          r,←⊂' Restore original text   : OnRestoreText     {restore}   ;Restores the text as it was when the editor was started'
      :EndIf
      r,←⊂' Find=Ctrl+F                 : OnFind            {find}      ;Search for text'
      r,←⊂' ~Next hit=F3                : OnNextHit         {nextHit}   ;SHow next hit, if any'
    ∇

    ∇ {(text changeFlag)}←ModalWait n
    ⍝ Takes a ref pointing to a form created by this class.\\
    ⍝ Returns:
    ⍝ | `changeFlag` | Boolean that indiates whether the text got changed or not.
    ⍝ | `text`       | The (maybe changed) text.
      :Access Public Shared
      {}⎕NQ n.Edit'GotFocus' ⋄ ⎕DQ n.∆Form
      changeFlag←n.∆changeFlag
      :If 0=n.⎕NC'∆result'
          text←''
      :Else
          text←n.∆result
      :EndIf
    ∇

      GetTextFromClipboard←{
          0::''
          (⎕NEW⊂'Clipboard').Text
      }

      SendKeyToEdit←{
          n←GetRefTo_n ⍵
          ⍬⊣2 ⎕NQ n.Edit'KeyPress'⍺
      }

      SavePosnAndSize←{
          n←⍵
          ##.APLGuiHelpers.SavePosnAndSizeInRegistry n
      }

      ExecuteOnInitial←{
          n←⍵
          0=≢n.∆parms.onInitial:⍬
          (parent name)←{2=≡⍵:⍵ ⋄ ⎕THIS ⍵}n.∆parms.onInitial
          0=≢name:⍬
          fns←parent⍎name
          _←fns n
          ⍬
      }

    ∇ {r}←OnCheckForChange msg;n;f2;f1;lastRedoUndo
      r←⍬
      n←GetRefTo_n↑msg
    ⍝ First we check whether anything has changed compared with where we started from. If so then
    ⍝ the user expects the "Save" command to be available.
      :If 0≠n.menubar.⎕NC'save'
          n.menubar.save.Active←n.Edit.Text≢n.∆originalText
      :EndIf
    ⍝ We also need to find out whether the user has changed the position of the cursor either directly
    ⍝ (= moving the cursor somehow) or indirectly (entering glyphs or pressing <DEL> or <ENTER> etc).
    ⍝ If that is the case we need to save the current state of the edited text and the last cursor
    ⍝ position in the UndoRedo stack.
      lastRedoUndo←'⊃'n.∆Commit ¯1
      :If ¯1≡1⊃lastRedoUndo
          f1←(≢n.Edit.Text)≢≢n.∆originalText           ⍝ Something added or removed?
      :Else
          f1←(≢n.Edit.Text)≢≢1 1⊃lastRedoUndo          ⍝ Something added or removed?
      :EndIf
      f2←(↑¨n.Edit.SelText)∨.≠(↑¨n.∆LastSelText)       ⍝ Has the cursor changed to a different line?
      :If ¯1≡1⊃lastRedoUndo
          f2←0
      :Else
          f2∧←n.Edit.Text≢1 1⊃lastRedoUndo
      :EndIf
      :If f1∨f2
          ⎕DL 0.001
          n.∆Commit n.∆LastSelText n.Edit.Text
          :If n.∆parms.undoRedoBufferLength∨.<'?'n.∆Commit 0
              '↑'n.∆Commit n.∆parms.undoRedoBufferLength
          :EndIf
          n.menubar.undo.Active←0<1⊃'?'n.∆Commit 0
      :EndIf
      n.∆LastSelText←n.Edit.SelText
    ∇

    ∇ parms←CheckParmsConsistency(parms filename)
      :If parms.hasMenuItem_Save∨parms.hasMenuItem_SaveAs
      :AndIf 0=≢filename
      :AndIf 0=parms.hasMenuItem_Open
          'filename is empty but hasMenuItemsSave(as) is 1'⎕SIGNAL APLGuiError
      :ElseIf 0≠≢filename
      :AndIf 0=+/parms.(hasMenuItem_Save hasMenuItem_SaveAs)
          'filename is not empty but hasMenuItemsSave(as) are both 0'⎕SIGNAL APLGuiError
      :ElseIf 0=≢filename
      :AndIf 0=parms.hasMenuItem_Open
          'filename is empty and hasMenuItem_Open is 0'⎕SIGNAL APLGuiError
      :ElseIf parms.hasMenuItem_Open
      :AndIf 0=≢parms.onFileOpen
          'hasMenuItem_Open is 1 but not callback is defined'⎕SIGNAL APLGuiError
      :EndIf
    ∇

    ∇ {r}←LoadFileIntoEdit(n filename);buffer
      r←⍬
      :If 1=≡buffer←⊃⎕NGET filename
      :AndIf (⎕UCS 13)∊buffer
          buffer←(⎕UCS 13)##.APLTreeUtils2.Split buffer
      :EndIf
      n.∆originalText←n.Edit.Text←buffer
      :If 0<n.menubar.⎕NC'open'
          n.menubar.open.Active←0
      :EndIf
    ∇

    ∇ r←AskForSave n;parms
      parms←##.Dialogs.CreateParmsForYesNoCancel
      parms.centerIn←n.∆Form
      parms.addToCaption←'"',n.∆Form.Caption,'"'
      r←↑n.∆globalParms parms ##.Dialogs.YesNoCancel'Save changes?'
    ∇

    ∇ r←HandleQuitInEditMode n;fns;parent;name
      r←1
      :If n.∆parms.readOnly
          n.∆CloseForm
          n.∆Form.∆closed←1
          r←0
      :ElseIf n.∆originalText≢n.Edit.Text
          :If n.∆askForSave
              :Select AskForSave n
              :Case 0
                  n.∆changeFlag←0
                  n.∆CloseForm
                  n.∆Form.∆closed←1
                  n.∆result←n.∆originalText
              :Case 1
                  :If 0≠≢n.∆parms.onClose
                      (parent name)←{2=≡⍵:⍵ ⋄ ⎕THIS ⍵}n.∆parms.onClose
                      fns←parent⍎name
                  :AndIf fns n
                      r←0
                      :Return
                  :EndIf
                  :If 0<n.⎕NC'∆filename'
                  :AndIf 0≠≢n.∆filename
                      (⊂n.Edit.Text)⎕NPUT n.∆filename 1
                  :EndIf
                  n.∆result←n.Edit.Text
                  n.∆changeFlag←1
                  n.∆CloseForm
                  n.∆Form.∆closed←1
              :Case ¯1
                  r←0
              :Else
                  . ⍝ Huuh?!
              :EndSelect
          :Else
              :If 0≠≢n.∆parms.onClose
                  (parent name)←{2=≡⍵:⍵ ⋄ ⎕THIS ⍵}n.∆parms.onClose
                  fns←parent⍎name
              :AndIf fns n
                  r←0
                  :Return
              :EndIf
              n.∆changeFlag←1
              n.∆CloseForm
              n.∆Form.∆closed←1
          :EndIf
      :Else
          r←0
          n.∆CloseForm
          n.∆Form.∆closed←1
      :EndIf
    ∇

    ∇ {r}←FindInText n;parms;defMat;res;txt;line;buff;ind;where
      r←⍬
      parms←#.GUI.Input.CreateParms
      parms.centerIn←n.∆Form
      parms.caption←'Find in: ',n.∆Form.Caption
      parms.onInitial←'OnInitialFind'
      defMat←0 7⍴''
      defMat⍪←'SearchFor' 'Find what:'n.∆LastSearchString #.GUI.Enums.InputDataTypes.Character(40 100)1 1
      defMat⍪←'MatchCase' 'Match &case'n.∆MatchCase #.GUI.Enums.InputDataTypes.YesNo 0 1 1
      defMat⍪←'MatchWord' 'Match whole &word only'n.∆MatchWord #.GUI.Enums.InputDataTypes.YesNo 0 1 1
      buff←'Start search from...⋄the &top⋄cursor &position'
      ind←(1=↑↑n.Edit.SelText)⊃1 0
      defMat⍪←'Start'buff ind #.GUI.Enums.InputDataTypes.Radio 0 1 2
      res←n.∆globalParms parms #.GUI.Input.Run defMat
      :If 0≠≢res
          n.(∆LastSearchString ∆MatchCase ∆MatchWord ∆StartOptions)←res[;1]
          n.∆LastSearchString←⎕C⍣(~n.∆MatchCase)⊣n.∆LastSearchString
          :If n.∆StartOptions≡0 1  ⍝ From cursor position?
              buff←(¯1+↑↑n.Edit.SelText)↓n.Edit.Text
              (0⊃buff)←(¯1+0 1⊃n.Edit.SelText)↓0⊃buff
          :Else
              buff←n.Edit.Text
          :EndIf
          :If n.∆MatchWord
              :If 0=≢∊where←{(('\b',n.∆LastSearchString,'\b')⎕S 0⍠'IC'n.∆MatchCase)⍵}¨buff
                  n.∆Hits←⍬
              :Else
                  n.∆Hits←⊃,/{(↑⍵),¨1↓⍵}¨{b←≢¨⍵ ⋄ (0<b)/(⍳≢b),¨⍵}where
              :EndIf
          :Else
              txt←⎕C⍣(~n.∆MatchCase)⊣buff
              :If 0=≢∊where←⍸¨n.∆LastSearchString∘⍷¨txt
                  n.∆Hits←⍬
              :Else
                  n.∆Hits←⊃,/{(↑⍵),¨1↓⍵}¨{b←≢¨⍵ ⋄ (0<b)/(⍳≢b),¨⍵}where
              :EndIf
          :EndIf
          :If 0=≢∊n.∆Hits
              n.∆Ind←⍬
              n.StatusField1.Text←''
              n.menubar.nextHit.Active←0
              n.StatusField1.Text←'Text "',n.∆LastSearchString,'" not found.'
          :Else
              :If n.∆StartOptions≡0 1  ⍝ If from cursor position then we have to correct the findings
                  :If 0=↑↑n.∆Hits
                      (0 1⊃n.∆Hits)+←¯1+0 1⊃n.Edit.SelText
                  :EndIf
                  (0⊃¨n.∆Hits)+←¯1+↑↑n.Edit.SelText
              :EndIf
              line←↑↑n.∆Hits
              n.∆Ind←0
              n.Edit.SelText←(1+line),¨(1(1+≢n.∆LastSearchString))+0 1⊃n.∆Hits
              n.StatusField1.Text←'Text "',n.∆LastSearchString,'" found ',(⍕{+/0<≢¨⍵}n.∆Hits),' times. -',(⍕1+n.∆Ind),'- is highlighted.'
              n.menubar.nextHit.Active←1
          :EndIf
      :EndIf
    ∇

      UndoRedo←{⎕ML←1                     ⍝ Derive undo/redo function. Taken from John Schole's dfns workspace and modified (pick added)
          ⍺←⊢                             ⍝ default: commit values.
          1≡⍺ 1:⍺⍺.(redo undo←⍬(⍵ undo))  ⍝ monadic commit: push new history record.
     
          '!'≡⍺:⍺⍺.(redo undo←⊂⍬)         ⍝ initialize history stacks.
     
          '?'≡⍺:0{                        ⍝ size of redo and undo stacks.
              ⍵≡⍬:⍺                       ⍝ empty: 0
              (⍺+1)∇⊃⌽⍵                   ⍝ otherwise: 1+length of tail.
          }¨⍺⍺.(redo undo)                ⍝ accumulates stack size in ⍺.
     
          '<'≡⍺:⍺⍺{                       ⍝ undo:
              ⍬≡⍺.undo:⍵                  ⍝ no more undo: state unchanged.
              ⍺.(redo←⍵ redo)             ⍝ push current state on redo stack.
              ⊃last ⍺.undo←⍺.undo         ⍝ pop undo stack.
          }⍵
     
          '⊃'≡⍺:⍺⍺{                       ⍝ pick: return latest redo/undo (or ⍬)
              (⍺{⍬≡⍺.redo:⍵ ⋄ ⊃⍺.redo}⍵)(⍺{⍬≡⍺.undo:⍵ ⋄ ⊃⍺.undo}⍵)
          }⍵
     
          '>'≡⍺:⍺⍺{                       ⍝ redo:
              ⍬≡⍺.redo:⍵                  ⍝ no more redo: state unchanged.
              ⍺.(undo←⍵ undo)             ⍝ push current state on undo stack.
              ⊃next ⍺.redo←⍺.redo         ⍝ pop redo stack.
          }⍵
     
          '↑'≡⍺:⍺⍺.undo←⍵{                ⍝ truncate undo stack to ⍵ items.
              ⍺=0:⍬                       ⍝ 0 items: empty stack.
              head tail←⍵                 ⍝ first and remaining items.
              head{⍺ ⍵}(⍺-1)∇ tail        ⍝ first cons (⍺-1) take of tail.
          }⍺⍺.undo                        ⍝ undo stack.
      }

    ∇ {r}←AddFontMenu n;this;c
      r←⍬
      n.menubar.fontMenu←n.menubar.file.##.⎕NEW'Menu'(⊂('Caption' 'Fonts'))
      n.menubar.fontMenuItems←⍬
      :For this :In n.∆parms.fontInput
          c←this.PName,' (',(⍕this.Size),')'
          n.menubar.fontMenuItems,←n.menubar.fontMenu.⎕NEW'MenuItem'(⊂('Caption'c))
      :EndFor
      n.menubar.fontMenuItems.onSelect←⊂'OnChangeFont'
      n.menubar.fontMenuItems[0].Checked←1
    ∇

      OnChangeFont←{
          rf←↑⍵
          n←GetRefTo_n rf
          ind←n.menubar.fontMenuItems⍳rf
          n.Edit.FontObj←ind⊃n.∆parms.fontInput
          n.menubar.fontMenuItems.Checked←0
          n.menubar.fontMenuItems[ind].Checked←1
          ⍬
      }

    :endSection

:EndClass
