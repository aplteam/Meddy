:Class Input
 ⍝TODO⍝  Add proper documentation

    :Include APLGuiUtils

    ⎕IO←0 ⋄ ⎕ML←3

    :Field Public Shared ReadOnly QuitEvent←9998
    :Field Public Shared ReadOnly CheckLengthEvent←9997
    :Field Public Shared ReadOnly DebugContextMenu←9995
    :Field Public Shared ReadOnly ShowMsgEvent←9994

    TAB←⎕UCS 9

    :Section Public

    ∇ r←Version
      :Access Public Shared
      r←(⍕⎕THIS)'1.3.0' '2018-11-14'
    ∇

    ∇ History
     ⍝ * 1.3.0
     ⍝   * Data type "URL" removed.
     ⍝   * Instead every item in a label that matches this regular expression:\\
     ⍝     ^<(http|https|ftp:tftp:mailto)://.+?>$'\\
     ⍝     Is transformed into a URL: blue color, underlined, acts on a click.\\
     ⍝     Note that this implies that a URL must stand on its own.
     ⍝ * 1.2.1
     ⍝   * Bug fix: size calculation of the final Form in `Input` was ruined by 1.2.0
     ⍝ * 1.2.0
     ⍝   * Data type "URL" introduced.
    ∇

    ∇ r←CreateParms
      :Access Public Shared
    ⍝ Returns a parameter namespace with default settings for being fed to `Input.Run` or `Input.Create`.
      r←##.APLGuiParameterSpace.Create
      r.addToCaption←''
      r.alignButtons←##.Enums.Align.Left
      r.appendColon←1
      r.autoPress←¯1
      r.cancelBtnCaption←'Cancel'
      r.cancel←1    ⍝ 1: <Cancel> triggers the "Cancel" button
      r.caption←''
      r.centerIn←''
      r.confirmCancel←0 ⍝ 1: ask user "Are you sure?"
      r.debug←0
      r.default←1   ⍝ 1: <Enter> triggers the "OK" button
      r.focus←''    ⍝ Field that get the focus initially. Name or empty. Default is first field.
      r.(fontAPL fontInput fontLabel fontStandard)←⊂''
      r.hasStatusbar←1
      r.hasProgressbar←0
      r.helpBtnCaption←''   ⍝ Default: no help button
      r.hGap←¯1
      r.icon←''
      r.initialVgap←¯1
      r.menubar←¯1
      r.minSize←200 300
      r.okBtnCaption←'OK'
      r.onChange←''
      r.onHelp←''
      r.onInitial←''
      r.onInitialMsg←''
      r.onKeyPress←''
      r.onOkay←''
      r.onPushButton←''
      r.parent←''
      r.parmType←'Input'
      r.posn←⍬ ⍬
      r.props←0 2⍴⍬      ⍝ Matrix with control names & properties
      r.regKey2←¯1
      r.selTextStyle←##.Enums.SelTextStyles.Full
      r.size←⍬ ⍬
      r.testMode←0
      r.timeout←0
      r.tips←0 2⍴⍬       ⍝ Matrix with control names & tips
      r.visible←1        ⍝ Set this to 0 in order to avoid any flickering
      r.vGap←0.75
      r.watchLength←1
    ∇

    ∇ r←{x}Run defMat;globalParms;parms;parms2;n
      :Access Public Shared
      'Right argument must not be empty'⎕SIGNAL 11/⍨0=≢defMat
      'Right argument must be a matrix '⎕SIGNAL 11/⍨2≠⍴⍴defMat
      'Ambiguous control names'⎕SIGNAL 11/⍨{(≢∪⍵)≠≢⍵}defMat[;##.Enums.DefMatIndices.ControlName]
      'Invalid control name (must not start with "_" or "∆"'⎕SIGNAL 11/⍨∨/{(↑⍵)∊'∆_'}¨defMat[;##.Enums.DefMatIndices.ControlName]
      x←{(0<⎕NC ⍵):⍎⍵ ⋄ ⍬}'x'
      (globalParms parms)←CreateParms GetParms x
      n←Create defMat parms globalParms
      DQ n
      r←(0=≢n.∆result)⊃(n.∆result)(⍬)
    ∇

    ∇ n←{x}Create(defMat parms globalParms);n
      :Access Public Shared
      (globalParms parms)←(CreateParms 1)GetParms parms globalParms
      parms←ParmsGymnastics parms defMat
      CheckParms parms defMat
      parms←CheckCallbacks parms
      'Definition matrix does not have the minimum of 5 columns?!'⎕SIGNAL 11/⍨~(1⊃⍴defMat)∊4+⍳9
      defMat←BlowUpDefMat defMat
      defMat←parms CheckDefMat defMat
      n←CreateForm globalParms parms
      n←SetGlobalVars n defMat
      n.∆g.Height←GetHeight n
      n←AddMenubar n
      n←AddTabsAndOrSubForm n
      n←AddButtons n
      n←AddHelpCallback n parms
      n←AddControls n
      n←AddTips n
      {}SelectFirstTab n
      ExecOnInitial n
      AdjustListViewAndNotepad n
      n←AdjustSize n
      {}n.∆Form ##.APLGuiHelpers.CenterIn globalParms.centerIn{(0=≢⍵):⍺ ⋄ ⍵}parms.centerIn
      n←PositionButtons n
      n←ReorderTabIndex n
      n←n CreateAutoPressTimer parms.timeout
      ExecOnInitialMsg n
      n.∆Form.Visible←parms.visible
    ∇

    ∇ r←PublicMethods
      :Access Public Shared
      r←'CreateParms' 'E' 'GetDefaultMenubar' 'I' 'PublicMethods' 'Run' 'Version' 'WriteToStatusbar'
    ∇

    ∇ r←I
      :Access Public Shared
      r←##.Enums.DefMatIndices
    ∇

    ∇ r←E
      :Access Public Shared
      r←##.Enums.InputDataTypes
    ∇

    ∇ {r}←{focus}DQ n;defMat
      :Access Public Shared
      focus←n.∆parms.focus{0=⎕NC ⍵:⍺ ⋄ ⍎⍵}'focus'
      n ForceFocusTo focus
      n.∆Form.Visible←1
      r←⎕DQ n.∆Form
    ⍝Done
    ∇

⍝⍝    ∇ {r}←ViewDefinitionMatrix y;n;defMat;parms;DT;I
⍝⍝ ⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹
⍝⍝ ⌹  We neeed the `Table` class for this! ⌹
⍝⍝ ⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹
⍝⍝      :Access Public Shared
⍝⍝      'Missing: "Table" class'⎕SIGNAL 6/⍨0=##.⎕NC'Table'
⍝⍝      DT←##.Enums.InputDataTypes.∆List
⍝⍝      I←##.Enums.DefMatIndices
⍝⍝      :If 2=⍴⍴y
⍝⍝          defMat←y
⍝⍝          n←⍬
⍝⍝      :Else
⍝⍝          n←y
⍝⍝          defMat←n.∆g.defMat
⍝⍝      :EndIf
⍝⍝      parms←##.Table.CreateParms
⍝⍝      parms.caption←'Definition matrix'
⍝⍝      :If ⍬≢n
⍝⍝          :If 0≠≢n.∆globalParms.caption
⍝⍝              parms.addToCaption,←' of ',n.∆globalParms.caption
⍝⍝          :EndIf
⍝⍝ ⍝TODO⍝           parms.centerIn←n.∆Form
⍝⍝      :EndIf
⍝⍝      parms.colTitles←'Name' 'Label' 'Default' 'Data type' 'Length' 'Active' 'Column'
⍝⍝      parms.dataTypes←##.Enums.TableDataTypes.(Char Char Char Char Char YesNo Numeric)
⍝⍝      defMat[;I.DataType]←DT[DT[;1]⍳defMat[;I.DataType];0]
⍝⍝      defMat[;I.Length]←⍕¨defMat[;I.Length]
⍝⍝      defMat[;I.Default]←(0=≢¨defMat[;I.Default])⊃¨⊂'Defined' ''
⍝⍝      parms ##.Table.Browse defMat
⍝⍝    ⍝Done
⍝⍝    ∇

⍝⍝    ∇ defMat2←EditDefinitionMatrix defMat;n;parms;DT;I;settings;data
⍝⍝      :Access Public Shared
⍝⍝      'Missing: "Table" class'⎕SIGNAL 6/⍨0=##.⎕NC'Table'
⍝⍝      DT←##.Enums.InputDataTypes.∆List
⍝⍝      I←##.Enums.DefMatIndices
⍝⍝      parms←##.Table.CreateParms
⍝⍝      parms.caption←'Definition matrix'
⍝⍝      parms.colTitles←'Name' 'Label' 'Default' 'Data type' 'Length' 'Active' 'Column'
⍝⍝      parms.dataTypes←##.Enums.TableDataTypes.(Char Char Char DropDown Char YesNo Numeric)
⍝⍝      parms.lists←⊂(I.DataType(##.Enums.InputDataTypes.∆List[;0]))
⍝⍝      parms.rowPrototype←'{name}' '' '' 'Character' 0 1 1
⍝⍝      parms.moveLines←1
⍝⍝      parms.onClose←(⍕⎕THIS),'.OnCheckEditDefMatResult'
⍝⍝      parms.readOnly←0 0 1 0 0 0 0
⍝⍝      defMat2←defMat
⍝⍝      defMat2[;I.DataType]←DT[DT[;1]⍳defMat[;I.DataType];0]
⍝⍝      defMat2[;I.Length]←⍕¨defMat[;I.Length]
⍝⍝      parms.data←defMat2[;,I.Default]
⍝⍝      defMat2[;I.Default]←(0=≢¨defMat[;I.Default])⊃¨⊂'Defined' ''
⍝⍝      (defMat2 settings data)←parms ##.Table.Edit defMat2
⍝⍝      :If 0≠≢defMat2
⍝⍝          defMat2[;I.DataType]←##.Enums.InputDataTypes.∆List{⍺[⍺[;0]⍳⍵;1]}defMat2[;I.DataType]
⍝⍝          defMat2[;I.Length]←{↑(//)⎕VFI ⍵}¨defMat2[;I.Length]
⍝⍝          defMat2[;I.Default]←data
⍝⍝      :EndIf
⍝⍝    ⍝Done
⍝⍝    ∇

    ∇ n←n CreateAutoPressTimer timeout
      :Access Public Shared
      :If 0<timeout
          n←n CreateAutoPressTimer_ timeout
      :EndIf
    ∇

    ∇ {r}←n ForceFocusTo ctrl;defMat;tabNo
    ⍝ Forces the focus to `ctrl`. If `ctrl` is undefined (empty) it goes to the first active control.
    ⍝ Does change the Tab if `ctrl` is not on the current Tab.
    ⍝ Result: Boolean that indicates whether a Tab change was performed (1) or not (0).
      :Access Public Shared
      r←0
      :If 0=≢ctrl
          :If 0≠≢defMat←(n.∆g.defMat[;I.DataType]∊E.∆ListInputFields[;1])⌿n.∆g.defMat
          :AndIf 0≠≢defMat←(defMat[;I.Active])⌿defMat
              ctrl←n.⍎↑defMat[;0]
          :EndIf
      :EndIf
      :If 0≠≢ctrl                              ⍝ There might not be any active controls at all
          ctrl←n ConvertControlNameToRef ctrl
          :If 0<n.∆g.NoOfTabs                   ⍝ Are there any Tabs around?
              tabNo←n GetTabNoFor ctrl
          :AndIf tabNo≠n.∆TabButtons.State⍳1    ⍝ Is "ctrl" on the current one?
              1 ⎕NQ(tabNo⊃n.∆TabButtons)'Select'
          :EndIf
          ⎕NQ ctrl'GotFocus'
      :EndIf
    ∇

    ∇ {r}←{color}WriteToStatusbar(n text)
      :Access Public Shared
      r←⍬
      n.StatusField1.Text←text
      :If 0<⎕NC'color'
          n.StatusField1.BCol←color
      :Else
          n.StatusField1.BCol←0
      :EndIf
    ∇

    ∇ m←GetDefaultMenubar debugFlag
      :Access Public Shared
      m←''
      m,←⊂'[&Edit] {edit}'
      m,←⊂' Cut=Ctrl+X      : ',(⍕⎕THIS),'.OnCutCopyPaste   {cut}       ;Cut any selected piece of text and put it into the clipboard'
      m,←⊂' Copy=Ctrl+C     : ',(⍕⎕THIS),'.OnCutCopyPaste   {copy}      ;Copy currently selected data to the clipboard'
      m,←⊂' Paste=Ctrl+V    : ',(⍕⎕THIS),'.OnCutCopyPaste   {paste}     ;Paste the contents of the clipboard'
      :If 0<debugFlag
          m,←⊂'[Developers] {developers}'
          m,←⊂' Toggle magic grid : ',(⍕⎕THIS),'.OnToggleMagicGrid {toggleMagic} ;Toggle the magix grid (rows and cols)'
          m,←⊂' Edit user-defined callbacks... : ',(⍕⎕THIS),'.OnEditCallbacks {editCallbacks} ;Allow the programmer to edit all user-defined callbacks'
          m,←⊂' Browse "Input" class : ',(⍕⎕THIS),'.OnBrowseInput {editInput} ;Views the "Input" class with the editor (read-only)'
      :EndIf
    ∇

    :EndSection ⍝ Public

    :Section Callbacks

    ∇ r←OnCheckEditDefMatResult n;b;parms;names;msg;caption;noOf;length;p
      :Access Public Shared
      r←1  ⍝ = Let it pass
      p←⎕NS''
      p.(msg curCell)←''⍬
      p←CheckInDefMatResult_DataType n p
      p←CheckInDefMatResult_Names n p
      p←CheckInDefMatResult_Length(n p)
      ⍝ Okay, we are done. If there's something on msg the user got it wrong so we tell her.
      :If 0≠≢p.msg
          n.Grid.CurCell←(1+↑p.curCell)##.Enums.DefMatIndices.Length
          parms←##.Dialogs.CreateParmsForShowMsg
          parms.centerIn←n.∆Form
          parms.caption←'There is a problem!'
          parms.style←##.Enums.DialogStyles.Error
          n.∆globalParms parms ##.Dialogs.ShowMsg p.msg
          r←0
      :EndIf
    ∇

    ∇ p←CheckInDefMatResult_DataType(n p);b
      :If 0<+/b←~n.∆result[;##.Enums.DefMatIndices.DataType]∊##.Enums.InputDataTypes.∆List[;0]
          p.msg,←⊂(⍕+/b),' row(s) carry an invalid data type.'
          p.curCell,←b⍳1
      :EndIf
    ∇

    ∇ p←CheckInDefMatResult_Names(n p);names;b;noOf
    ⍝ Names must be valid APL names and unique.
      names←n.Grid.Values[;##.Enums.DefMatIndices.ControlName]
      :If 0<+/b←¯1=↑¨⎕NC¨names
          p.msg,←⊂(⍕+/b),' row(s) carries an invalid name.'
          p.curCell←b⍳1
      :EndIf
      :If 0<noOf←(≢names)-≢∪names
          p.msg,←⊂(⍕noOf),' row(s) do not carry a unique name.'
      :EndIf
    ∇

    ∇ p←CheckInDefMatResult_Length(n p);length;b;b2
    ⍝ Has "length a length of 1 or 2?
      length←n.Grid.Values[;##.Enums.DefMatIndices.Length]
      :If 0<+/b←~{1 2∊⍨↑⍴' 'Split ⍵}¨length
          p.msg,←⊂'Length of "Length" is invalid in row(s) ',↑{⍺,', ',⍵}/⍕¨1+⍸b
          p.curCell←b⍳0
      :EndIf
    ⍝ Does "length" contain just numerically valid stuff?
      b←~{∧/↑⎕VFI ⍵}¨length
      b∨←~{∧/⍵∊⎕D,'¯ '}¨length  ⍝ Because 1e6 is numeric but still invalid
      :If 0<+/b
          p.msg,←⊂'Invalid "Length" in row(s) ',↑{⍺,', ',⍵}/⍕¨1+⍸b
      :EndIf
    ∇

    ∇ OnEditCallbacks(n rf);list;active;parms
      :Access Public Shared
      list←GetAllUserDefinedCallbacks n
      active←0<≢¨list
      parms←##.ProcessTool.CreateParms
      :If 0=≢n.∆Form.Caption
          parms.caption←'Edit Callbacks'
      :Else
          parms.caption←'Callbacks of "',n.∆Form.Caption,'"'
      :EndIf
      parms.centerIn←n.∆Form
      parms.info←'Select the callbacks you want to edit:'
      parms.processBtnCaption←'Edit'
      parms.colTitles←'Name' 'Edited'
      parms.sortByCol←0
      parms.dblClick←1
      parms.ctrlEnter←1
      parms.debug←{0<⎕NC ⍵:⍎⍵ ⋄ 0}'n.∆parms.debug'
      parms.data←⊃GetAllUserDefinedCallbacks n
      n.∆globalParms parms ##.ProcessTool.Run((1⊃¨list),[0.7]⊂'Not yet')((⍕⎕THIS),'.OnEditCallback')
      ⍝Done
    ∇

    ∇ r←OnEditCallback msg;bool;n;list;name;parent;getBody;body;body2
      :Access Public Shared
      r←⍬
      (bool n)←1↓msg
      (parent name)←,bool⌿n.∆data
      getBody←parent∘{9=⍺.⎕NC ⍵:parent.⎕SRC⍎name ⋄ parent.⎕NR name}
      body←getBody name
      (parent.⎕ED⍠('ReadOnly' 0)('EditName' 'Allow'))name
      body2←getBody name
      :If body≢body2
          n.List.ReportInfo[⍸bool;0]←⊂'Edited'
      :EndIf
    ∇

    ∇ OnBrowseInput(n rf)
      :Access Public Shared
      (⎕ED⍠('ReadOnly' 1)('EditName' 'Allow'))(⍕⎕THIS)
    ∇

    ∇ OnToggleMagicGrid(n rf)
      :Access Public Shared
      rf.Checked←ShowOrHideMagicGrid n
    ∇

      OnKeyPressInButton←{
          (rf key)←⍵[0 2]
          n←GetRefTo_n rf
          ~(⊂key)∊'TB' 'BT':1  ⍝ We are interested only in Ctrl+Tab & Ctrl+Shift+Tab
          bool2←(('TB' 'BT'⍳⊂key)⊃¯1 1)⌽n.∆TabButtons.State
          _←⎕NQ((bool2⍳1)⊃n.∆TabButtons)'Select'
          0
      }

      OnFormGotFocus←{
      ⍝ Establish former status when focus come back from another application.
          (rf comingFrom)←⍵[0 2]
          0≠≢comingFrom:1                  ⍝ Not coming from another application? Done.
          n←GetRefTo_n rf
          0=n.∆g.RefuseTabChange:1
          _←2 ⎕NQ n.∆g.LastTabWas'Select'
          0=≢n.∆g.LastCtrlWas:1
          _←⎕NQ n.∆g.LastCtrlWas'GotFocus'
          1
      }

    ∇ r←OnTabSelect msg;tab;n
      tab←↑msg
      n←GetRefTo_n tab
      :If n.∆g.ChangeRejected∨n.∆g.RefuseTabChange
          {}2 ⎕NQ n.∆g.LastTabWas'Select'
          r←0
      :Else
          n.∆g.LastTabWas←tab
          r←1
      :EndIf
    ∇

      OnShowMsg←{
          rf←↑⍵
          n←GetRefTo_n rf
          (ctrl msg)←2⊃⍵
          _←n.∆globalParms.alarmColor WriteToStatusbar n msg
          ⍬
      }

    ∇ OnCutCopyPaste(n menuItem);n;focusHas;list;rf;key;a
      :Access Public Shared
      focusHas←2 ⎕NQ #'GetFocusObj'
      :If ⎕NULL≢focusHas
          list←n.∆GetRefs''
      :AndIf 0<≢rf←(focusHas=list)/list
          rf←↑rf
          key←(n.menubar.(cut copy paste)⍳menuItem)⊃'CT' 'CP' 'PT'
          ⎕NQ rf'KeyPress'key
      :EndIf
    ∇

    ∇ OnSelectUserDefinedPushButton msg;rf;n;parent;fns
      rf←↑msg
      n←GetRefTo_n rf
      :If 0=n.∆g.ChangeRejected
          parent←↑n.∆parms.onPushButton
          fns←parent⍎1⊃n.∆parms.onPushButton
          :If 0=FunctionReturnsResult parent(1⊃n.∆parms.onPushButton)
              fns rf n
          :Else
              {}fns rf n
          :EndIf
      :EndIf
    ∇

    ∇ {r}←OnCancel msg;rf;n;parms;flag
      r←1
      rf←↑msg
      n←GetRefTo_n rf
      :If n.∆parms.confirmCancel
          :If n.∆parms.testMode
              flag←0
          :Else
              parms←##.Dialogs.CreateParmsForYesOrNo
              parms.centerIn←n.∆Form
              parms.addToCaption←'Cancellation'
              parms.style←##.Enums.DialogStyles.Query
              flag←~n.∆globalParms parms ##.Dialogs.YesOrNo'Are you sure?'
          :EndIf
      :AndIf flag
          r←0
      :Else
          n.∆result←⍬
          n.∆CloseForm
      :EndIf
    ∇

    ∇ r←OnShowDebugContextMenu msg;rf;n;mm;res;caption;menu
      r←0
      rf←↑msg
      n←GetRefTo_n rf
      (res menu)←ShowContextMenu n
      :If 0≠≢res
          .  ⍝TODO⍝  User-defined context menu?!
          :Select res
          :Case
     
          :Else
              . ⍝ Huuh?!
          :EndSelect
      :EndIf
    ∇

    ∇ r←OnGotFocus msg;n;rf;type;txt;maxLength;length
      rf←↑msg
      n←GetRefTo_n rf
      n.∆g.LastCtrlWas←''
      r←1
      →((⊂rf.Type)∊'Form' 'SubForm')/0
      {}HandelSelText⍣(↑(⊂rf.Type)∊'Edit' 'Combo')⊣rf n
      HandelSelItems rf n
      ⎕NQ rf CheckLengthEvent
    ∇

    ∇ r←OnLostFocus msg;rf;nextControl;n
      (rf nextControl)←(3↑msg)[0 2]
      n←GetRefTo_n rf
      r←1
      n.∆g.LastCtrlWas←rf
      :If 0=≢nextControl
      :AndIf 0<n.∆g.NoOfTabs
          n.∆g.LastTabWas←(n.∆TabButtons.State⍳1)⊃n.∆TabButtons
      :ElseIf nextControl≡n.∆Cancel
          :Return
      :Else
          {}WriteToStatusbar⍣(DoesStatusFieldShowAlarm n)⊣n''
          :If (⊂rf.Type)∊'Edit' 'Combo'
              rf.∆LastSelText←rf.SelText
              rf.SelText←0 0
          :EndIf
      :EndIf
    ∇

    ∇ r←OnOkay msg;rf;n;rc;focusTo;parent;fns;buffer
      rf←↑msg
      n←GetRefTo_n rf
      :If n.∆g.ChangeRejected
          r←0       ⍝ User has changed a field and then triggered the "OK" button but user-defined "OnChange" callback refused the change!
      :Else
          n.∆result←GetResults n
          :If 0=≢n.∆parms.onOkay
              r←1
          :Else
              parent←↑n.∆parms.onOkay
              fns←parent⍎1⊃n.∆parms.onOkay
              buffer←fns n
              :If 1=≢buffer
                  r←buffer
                  focusTo←''
              :ElseIf 2=≢buffer
                  (r focusTo)←buffer
              :Else
                  '"OnOkay" callback returned an invalid result'⎕SIGNAL 11
              :EndIf
              :If 0=r
                  :If 0≠≢focusTo
                      2 ⎕NQ focusTo'GotFocus'
                  :EndIf
                  :Return
              :EndIf
          :EndIf
          ⎕NQ n.∆Form ##.Enums.Events.QuitDQ
          2 ⎕NQ n.∆Form'Close'
          n.∆Form.∆closed←1
      :EndIf
    ∇

    ∇ {r}←OnHelp msg;n;parent;fns
      r←⍬
      n←GetRefTo_n↑msg
      parent←↑n.∆parms.onHelp
      fns←parent⍎1⊃n.∆parms.onHelp
      :If FunctionReturnsResult parent(1⊃n.∆parms.onHelp)
          {}fns n
      :Else
          fns n
      :EndIf
    ∇

    ∇ r←OnChange msg;msg_;type;changeFocusTo;n;tabNo;ctrl;flag;parms
      (ctrl type changeFocusTo)←msg_←3↑msg,⊂''
      n←GetRefTo_n ctrl
      {}0 WriteToStatusbar n''
      r←1                                               ⍝ Permits the change
      n.∆g.ChangeRejected←0                             ⍝ May indicate that the change was not permitted (important in case user pressed the OK button!)
      :If 0=n.∆g.Cancelled                              ⍝ Only if the user has NOT pressed "Cancel"
          :If 0≠≢n.∆parms.onChange                     ⍝ Is there a user-defined "Change" callback?
              (flag msg)←ExecUserDefinedOnChange ctrl n
              :If 0=flag
                  r←0                                   ⍝ The change...
                  n.∆g.ChangeRejected←1                 ⍝ ... is rejected
                  n ForceFocusTo ctrl
                  {}ShowChangeMsg n ctrl msg
              :EndIf
          :EndIf
      :EndIf
    ∇

    ∇ r←OnKeyPress msg;rf;event;key;ASCII;keyNo;shiftState;n
      r←1
      (rf event key ASCII keyNo shiftState)←6↑msg,(≢msg)↓⍬ ⍬ ⍬ 0 0 0
      n←GetRefTo_n rf
      n.∆g.LastKey←key
      n.StatusField1.BCol←0
      :If 'EP'≡key                                  ⍝ User has pressed the <escape> key...
      :AndIf 0≠≢n.∆Cancel                          ⍝ ... and there is a "Cancel" button...
      :AndIf n.∆Cancel.Cancel                       ⍝ ... and the "Cancel" button is associated with <escape>
          n.∆g.Cancelled←1
          :Return                                   ⍝ Get out without further ado.
      :ElseIf 'F1'≡key                              ⍝ Help key?
      :AndIf 0<n.⎕NC'∆Help'
          ⎕NQ n.∆Help'Select'
          →r←0
      :ElseIf rf.∆DataType=##.Enums.InputDataTypes.Notepad
      :AndIf (key≡'BT')∨(key≡'TB')∧2=shiftState     ⍝ Tab and Ctrl-Tab in a notepad need special attention.
          r←msg
          (↑r)←(↑r).##                              ⍝ Send it to the parent in order to switch Tab
      :ElseIf rf.∆DataType≡##.Enums.InputDataTypes.Spinner
          r←HandleKeyPressInSpinner rf key n
      :ElseIf rf.∆DataType∊##.Enums.InputDataTypes.(DropEdit DropDown)
          r←HandleKeyPressInComboxEx rf key n
      :Else
          r←ExecKeyPressCallback n msg
      :EndIf
    ∇

    ∇ OnCheckLength msg;n;ctrl
      ctrl←↑msg
      n←GetRefTo_n ctrl
      :If DoesStatusFieldShowAlarm n
          :If ctrl.∆DataType∊##.Enums.InputDataTypes.(Character Currency Numeric DropEdit Password)
              :If n.∆parms.watchLength
                  WriteToStatusbar n('Max length: ',(⍕ctrl.MaxLength),'; currently: ',(⍕≢ctrl.Text))
              :EndIf
          :ElseIf ctrl.∆DataType≡##.Enums.InputDataTypes.Spinner
              WriteToStatusbar n('Item ',(⍕ctrl.Thumb),' of ',((⍕≢ctrl.Items),' values'))
          :Else
              WriteToStatusbar n''
          :EndIf
      :EndIf
    ∇

    ∇ OnClose msg;rf;n
      rf←0⊃msg
      rf.n.∆Form.∆closed←1
      {}##.APLGuiHelpers.SavePosnAndSizeInRegistry rf.n
      rf.n.∆CloseForm
      rf.n.∆result←⍬
    ∇

    ∇ OnSelectURL msg;ref
      ref←↑msg
      :Trap 11
          GoToWebPage ref.Caption
      :EndTrap
    ∇

    :EndSection ⍝ Callbacks

    :Section CreateControls

    ∇ n←AddMenubar n;parmsMenubar;theMenu;list
      :If 0≠≢n.∆parms.menubar
          parmsMenubar←##.Menubar.CreateParms
          parmsMenubar.noDevelopersMenu←1
          parmsMenubar.debug←0
          :If n.∆parms.hasStatusbar
              parmsMenubar.hintObj←n.StatusField1
          :EndIf
          n.menubar←##.Menubar.Create n.∆Form n.∆parms.menubar parmsMenubar(⎕NEW ##.KeyCodes)
          :If 0≠≢list←GetAllMenuItems n.menubar
              n.menubar.∆Callbacks←list,[0.5]↑¨list.onSelect
              list.onSelect←⊂'OnMenuItem'
          :EndIf
      :EndIf
    ∇

    ∇ {n}←AddTips n;controlname;tip;rf;i
      n←AddTipField n
      :If 0≠≢n.∆parms.tips
          '"tip" parameter has invalid rank'⎕SIGNAL 11/⍨2≠⍴⍴n.∆parms.tips
          '"tip" parameter has invalid shape'⎕SIGNAL 11/⍨2≠1⊃⍴n.∆parms.tips
          :For i :In ⍳≢n.∆parms.tips
              (controlname tip)←n.∆parms.tips[i;]
              rf←n⍎controlname
              rf.TipObj←n.TipField
              rf.Tip←tip
          :EndFor
      :EndIf
    ∇

    ∇ {n}←AddTipField n;∆
      ∆←''
      ∆,←'FontObj'(n GetParm ##.Enums.Fonts.Label)
      n.TipField←n.∆Form.⎕NEW'TipField'(⊂∆)
    ∇

    ∇ n←AddButtons n
    ⍝ Add "OK" and "Cancel", and maybe "Help"
      :If 0=≢n.∆parms.helpBtnCaption
          n←##.StdForm.AddButtons n(n.∆parms.(okBtnCaption cancelBtnCaption))
          :If 0≠≢n.∆buttons
          :AndIf 0<n.⎕NC'Btn_00'
              n.Btn_00.Default←n.∆parms.default
              n.Btn_00.onSelect←'OnOkay'
              n.∆OK←n.Btn_00
          :Else
              n.∆OK←⍬
          :EndIf
          :If (,0)≢,n.∆parms.cancelBtnCaption
          :AndIf 0≠≢n.∆parms.cancelBtnCaption
              n.Btn_01.Cancel←n.∆parms.cancel
              n.Btn_01.onSelect←'OnCancel'
              n.∆Cancel←n.Btn_01
          :Else
              n.∆Cancel←⍬
          :EndIf
      :Else
          n←##.StdForm.AddButtons n(n.∆parms.(okBtnCaption helpBtnCaption cancelBtnCaption))
          n.Btn_00.Default←n.∆parms.default
          n.(Btn_00 Btn_01).onSelect←'OnOkay' 'OnHelp'
          n.(∆OK ∆Help)←n.(Btn_00 Btn_01)
          :If (,0)≢n.∆parms.cancelBtnCaption
              n.Btn_02.Cancel←n.∆parms.cancel
              n.Btn_02.onSelect←'OnCancel'
              n.∆Cancel←n.Btn_02
          :EndIf
      :EndIf
      :If 0≠≢n.∆buttons
          n.∆buttons.onKeyPress←⊂'OnKeyPressInButton'
      :EndIf
    ∇

    ∇ n←AddTabsAndOrSubForm n;bool;rf;labels
      :If 0=+/bool←##.Enums.InputDataTypes.Tab=↑¨n.∆g.defMat[;I.DataType]
          rf←n.∆Form.⎕NEW'SubForm'(('EdgeStyle' 'Dialog')('Attach'(4⍴'Top' 'Left' 'Bottom' 'Right')))
          ⍎'n.',n.∆parms.namePrefix,'SubForm←rf'
      :Else
          labels←bool⌿n.∆g.defMat[;I.Label]
          labels←{⍵↓⍨-↑':'=¯1↑⍵}¨labels     ⍝ Remove any ":"
          n←##.StdForm.AddTabs n labels(bool⌿n.∆g.defMat[;I.ControlName])
          n.∆TabButtons.onSelect←⊂'OnTabSelect'
      :EndIf
    ∇

    ∇ n←AddControls n;tabRows;tab;i;defMat_;p
    ⍝ Top-most control-adding fns
      n.∆g.ColumnsStartAt←n.∆g.NoOfTabs⍴⊂n.∆Hgap
      n.∆g.NoOfColumns←⍬
      p←⎕NS''
      p.colsStartAt←⍬
      p.startAt←n.(∆Hgap ∆initialVgap)
      p.cols←n.∆g.defMat[;I.Column]
      :If 0=n.∆g.NoOfTabs←CountTabsInDefMat n.∆g.defMat
      ⍝ No Tabs, just controls
          p.ctrl←n._SubForm
          n.∆g.defMat PopulateSubForm(n p)
          n.∆g.ColumnsStartAt←p.colsStartAt
      :Else
      ⍝ Has Tabs, so we loop through the Tabs
          n.∆g.ColumnsStartAt←n.∆g.NoOfTabs⍴⊂n.∆Hgap
          ⍝ Loop over the Tabs
          :For i defMat_ :InEach (⍳n.∆g.NoOfTabs)(SplitDefMatAtTabs n.∆g.defMat)
              p.ctrl←i⊃GetSubFormsOfTabs n
              defMat_ PopulateSubForm(n p)
              (i⊃n.∆g.ColumnsStartAt),←¯1↓p.colsStartAt
              p.startAt[1]←n.∆Hgap
          :EndFor
      :EndIf
    ∇

    ∇ {r}←defMat PopulateSubForm(n p);thisRow;defMat_;list;noOfCols;labels;width;col
    ⍝ In charge for populate a single sub form. That sub Form might be related to a Tab
    ⍝ (if there are any at all) or not; If not then their is just a single sub form.
      r←⍬
      noOfCols←0
      :For col :In ∪defMat[;I.Column]    ⍝ Loop through the columns
          defMat_←(defMat[;##.Enums.DefMatIndices.Column]=col)⌿defMat
          :If 0≠≢list←PopulateColumnWithControls defMat_ n p
              noOfCols+←1
              p.startAt[0]←n.∆initialVgap
              width←1⊃↑⌈/{+⌿⊃⍵}¨GetPosnAndSize list
              :If 0≠≢labels←n.∆List'Label'
                  width⌈←⌈⌿1⊃¨labels[;0].Size
              :EndIf
              p.startAt[1]←width+1×n.∆Hgap
              p.colsStartAt,←p.startAt[1]
          :EndIf
      :EndFor
      n.∆g.NoOfColumns,←noOfCols
    ∇

    ∇ {r}←PopulateColumnWithControls(defMat n p);def;d;fns;dataType
    ⍝ Populate a single column on a sub form.
      r←⍬
      :For def :In ↓defMat          ⍝ Loop through the controls
          dataType←I.DataType⊃def
          :If E.Tab≢dataType
              d←GetDefAsNamespace n def
              fns←⍎GetAddFnsName dataType
              r,←fns d n p(↑¯1↑r)
          :EndIf
      :EndFor
    ∇

    ∇ {r}←AddMagicGrid n;colIDs;i;defMats;allTabs;subFormList;startAt
    ⍝ Makes the magic grid visible to the user. Only with debug=1.
      r←⍬
      subFormList←{⍵[;0]}n.∆List'SubForm'
      startAt←n.(∆Vgap ∆Hgap)
      :If 0=n.∆g.NoOfTabs
          PaintLabelForEachColumn n(↑subFormList)n.∆g.defMat n.∆g.ColumnsStartAt
      :Else
          allTabs←{⍵[;0]}n.∆List'TabButton'
          defMats←SplitDefMatAtTabs n.∆g.defMat
          :For i :In ⍳≢subFormList
              PaintLabelForEachColumn n(i⊃,subFormList)(1↓i⊃defMats)(i⊃,n.∆g.ColumnsStartAt)
          :EndFor
      :EndIf
    ∇

    ∇ {n}←PaintLabelForEachColumn(n subForm defMat columnsStartAt);points;k;colIDs;columnStart;ctrls;∆;width
      colIDs←∪defMat[;I.Column]
      :For k :In ⍳≢colIDs
          points←n.∆Vgap,1↓n.∆g.Height×⍳⌈subForm.Size[0]÷n.∆g.Height
          :If 0≠≢ctrls←I.ControlName{⍵[;⍺]⌿⍨⍵[;I.Column]=k⊃colIDs}defMat
              ctrls←,↑,/n⍎¨ctrls
              width←⌈/1⊃¨1⊃¨GetPosnAndSize ctrls
              columnStart←k⊃,columnsStartAt
              ∆←''
              ∆,←⊂'Caption'(width⍴'⌹')
              ∆,←⊂'Size'(1,width)
              n.∆g.MagicGridLabels,←∆ PaintLabel n ∆ points subForm columnStart
          :EndIf
      :EndFor
    ∇

    ∇ {r}←props PaintLabel(n parent points parent colStart);props2;Vgap
      r←⍬
      :For Vgap :In points
          props2←props,⊂'Posn'(Vgap,colStart)
          r,←parent.⎕NEW'Label'props2
      :EndFor
    ∇

      GetAddFnsName←{
      ⍝ Returns the name of the "Add*" function that is associated with data type ⍵
          dataType←⍵
          'Add',↑E.∆GetName dataType
      }

    ∇ {button}←AddButton(d n p lo);∆;label;caption
    ⍝ Add user-defined buttons
      caption←d.label
      d.label←''
      label←CreateLabel n p d lo
      ∆←''
      ∆,←⊂'Style' 'Push'
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Standard)
      ∆,←d.props
      ∆,←⊂'Caption'caption
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      button←p.ctrl.⎕NEW'Button'∆
      ⍎'n.',(d.name~'&'),'←button'
      button.Posn←p.startAt
      :If 0=1↑1↓d.length
          button.Size[1]←1⊃button.GetTextSize(2+⍴caption)⍴'W'
      :Else
          button.Size[1]←1↑1↓d.length
      :EndIf
      p.startAt[0]←n.∆Hgap CalcNextPosn n button
      button.onGotFocus←'OnGotFocus'
      button.onLostFocus←'OnLostFocus'
      button.onKeyPress←'OnKeyPress'
      button.onSelect←'OnSelectUserDefinedPushButton'
      button.∆DataType←##.Enums.InputDataTypes.Button
      button.∆MyName←d.name
    ∇

    ∇ {edit}←AddCharacter(d n p lo);∆;edit;∆Default;label
      label←CreateLabel n p d lo
      p.startAt[0]←↑+⌿⊃label.(Posn Size)
      ∆←''
      ∆,←⊂'ValidIfEmpty' 1
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Text'({0 1∊⍨≡⍵:⍵ ⋄ 1↓↑,/(⎕UCS 10),¨⍵}d.default)
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      edit←p.ctrl.⎕NEW'Edit'∆
      edit.⎕DF d.name
      ⍎'n.',d.name,'←edit'
      CalcBestSizeForEditFieldsAndSetMaxLength edit d.length ##.Enums.InputDefaultLength.Character d.default
      edit.Posn←p.startAt
      p.startAt[0]←CalcNextPosn n edit
      edit.onGotFocus←'OnGotFocus'
      edit.onLostFocus←'OnLostFocus'
      edit.onChange←'OnChange'
      edit.onKeyPress←'OnKeyPress'
      AddWatchLengthCallback n edit
      edit.∆DataType←##.Enums.InputDataTypes.Character
      edit.∆Default←d.default
      edit.∆MyName←d.name    ⍝TODO⍝ Either everywhere or nowhere! (We should NOT need this!)
    ∇

    ∇ {edit}←AddCurrency(d n p lo);∆;size;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'ValidIfEmpty' 1
      ∆,←⊂'Decimals' 2
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      :If 0=1↑0⍴d.default
          ∆,←⊂'Text'(⍕↑d.default)
      :Else
          ('Invalid value in field "',d.name,'"')⎕SIGNAL 11/⍨1≠↑⎕VFI∊d.default
          ∆,←⊂'Text'(⍕1⊃⎕VFI∊d.default)
      :EndIf
      edit←p.ctrl.⎕NEW'Edit'∆
      edit.⎕DF d.name
      ⍎'n.',d.name,'←edit'
      edit.Posn←p.startAt
      CalcBestSizeForEditFieldsAndSetMaxLength edit d.length ##.Enums.InputDefaultLength.Currency edit.Text
      p.startAt[0]←n.∆Hgap CalcNextPosn n edit
      edit.onGotFocus←'OnGotFocus'
      edit.onLostFocus←'OnLostFocus'
      edit.onChange←'OnChange'
      edit.onKeyPress←'OnKeyPress'
      AddWatchLengthCallback n edit
      edit.∆DataType←##.Enums.InputDataTypes.Currency
      edit.∆Default←d.default
      edit.∆MyName←d.name
      edit.⎕DF d.name
    ∇

    ∇ {edit}←AddPassword(d n p lo);∆;size;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'ValidIfEmpty' 1
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'FieldType' 'Password'
      ∆,←⊂'Password' '*'
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      edit←p.ctrl.⎕NEW'Edit'∆
      edit.⎕DF d.name
      ⍎'n.',d.name,'←edit'
      CalcBestSizeForEditFieldsAndSetMaxLength edit d.length ##.Enums.InputDefaultLength.Character''
      edit.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n edit
      edit.onGotFocus←'OnGotFocus'
      edit.onLostFocus←'OnLostFocus'
      edit.onChange←'OnChange'
      edit.onKeyPress←'OnKeyPress'
      AddWatchLengthCallback n edit
      edit.∆DataType←##.Enums.InputDataTypes.Password
      edit.∆MyName←d.name
      edit.⎕DF d.name
    ∇

    ∇ {date}←AddDate(d n p lo);∆;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'HasCheckBox' 0
      date←p.ctrl.⎕NEW'DateTimePicker'∆
      ⍎'n.',d.name,'←date'
      date.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n date
      :If 0≠≢d.default
          date.DateTime←d.name ConvertDateTime d.default
      :EndIf
      date.onGotFocus←'OnGotFocus'
      date.onLostFocus←'OnLostFocus'
      date.onDateTimeChange←'OnChange'
      date.∆DataType←##.Enums.InputDataTypes.Date
      date.∆Default←d.default
      date.∆MyName←d.name
      date.⎕DF d.name
    ∇

    ∇ {combo}←AddDropDown(d n p lo);∆;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Items'd.default
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      combo←p.ctrl.⎕NEW'Combo'∆
      ⍎'n.',d.name,'←combo'
      CalcBestSizeForEditFieldsAndSetMaxLength combo d.length ##.Enums.InputDefaultLength.Numeric(GetLargestTextFrom combo)
      :If 0=(⊂'selitems')∊⎕C↑¨∆
          combo.SelItems←(≢d.default)↑1
      :EndIf
      combo.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n combo
      combo.onSelect←'OnChange'
      combo.onGotFocus←'OnGotFocus'
      combo.onLostFocus←'OnLostFocus'
      combo.onKeyPress←'OnKeyPress'
      combo.∆DataType←##.Enums.InputDataTypes.DropDown
      combo.∆Default←d.default
      combo.∆MyName←d.name
      combo.∆LastSelItems←⍬
      combo.⎕DF d.name
    ∇

    ∇ {combo}←AddDropEdit(d n p lo);∆;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Items'd.default
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'Style' 'DropEdit'
      combo←p.ctrl.⎕NEW'Combo'∆
      ⍎'n.',d.name,'←combo'
      CalcBestSizeForEditFieldsAndSetMaxLength combo d.length ##.Enums.InputDefaultLength.Numeric(GetLargestTextFrom combo)
      :If 0=(⊂'selitems')∊⎕C↑¨∆
          combo.SelItems←(≢d.default)↑1
      :EndIf
      combo.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n combo
      combo.onGotFocus←'OnGotFocus'
      combo.onLostFocus←'OnLostFocus'
      combo.onKeyPress←'OnKeyPress'
      AddWatchLengthCallback n combo
      combo.∆DataType←##.Enums.InputDataTypes.DropEdit
      combo.onChange←'OnChange'
      combo.∆Default←d.default
      combo.∆MyName←d.name
      combo.∆LastSelItems←⍬
      combo.⎕DF d.name
    ∇

    ∇ {label}←AddLabel(d n p lo);∆;pattern;isUrl
      :If '⋄'∊d.default
          d.default←'⋄'Split d.default
          label←AddLabels d n p lo
      :Else
          ∆←''
          ∆,←⊂'Posn'(p.startAt+0 2)
          ∆,←d.props
          ∆,←⊂'Attach'(4⍴'Top' 'Left')
          pattern←GetUrlSearchPattern
          :If isUrl←0<≢pattern ⎕S 1⍠('Mode' 'M')⊣d.default
              ∆,←⊂'Caption'(pattern ⎕R'\1'⍠('Mode' 'M')⊣d.default)
              ∆,←⊂'FCol'(0 0 255)
          :Else
              ∆,←⊂'Caption'd.default
          :EndIf
          label←p.ctrl.⎕NEW'Label'∆
          ⍎'n.',d.name,'←label'
          label.⎕DF d.name
          label.FontObj←CreateLabelFont label
          :If isUrl
              label.onMouseUp←'OnSelectURL'
          :EndIf
      :EndIf
      p.startAt[0]←n.∆Hgap CalcNextPosn n(↑¯1↑label)
      label.∆DataType←##.Enums.InputDataTypes.Label
      label.∆Default←⊂∘,⍣(↑1<≢label)⊣''
      label.∆MyName←⊂d.name
    ∇

    ∇ labels←AddLabels(d n p lo);∆;rf;label;caption;pattern;isUrl;sub
      labels←⍬
      :For caption :In d.default
          ∆←''
          ∆,←⊂'Posn'p.startAt
          ∆,←d.props
          ∆,←⊂'Caption'caption
          ∆,←⊂'Attach'(4⍴'Top' 'Left')
          pattern←GetUrlSearchPattern
          :If isUrl←0<≢pattern ⎕S 1⍠('Mode' 'M')⊣caption
              ∆,←⊂'Caption'(pattern ⎕R'\1'⍠('Mode' 'M')⊣caption)
              ∆,←⊂'FCol'(0 0 255)
              sub←4
          :Else
              ∆,←⊂'Caption'caption
              sub←6
          :EndIf
          label←p.ctrl.⎕NEW'Label'∆
          labels,←label
          p.startAt[0]+←label.Size[0]-sub
          :If isUrl
              label.onMouseUp←'OnSelectURL'
          :EndIf
          label.FontObj←CreateLabelFont label
      :EndFor
      ⍎'n.',d.name,'←labels'
    ∇

    ∇ {listView}←AddListView(d n p lo);∆;attach;needed;fac;label;borderHeight;size
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'VScroll' ¯1
      ∆,←⊂'FullRowSelect' 1
      ∆,←⊂'GridLines' 1
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←⊂'Posn'p.startAt
      ∆,←d.props
      ∆,←⊂'Active'd.active
      ∆,←⊂'Header'((0=≢d.props)⊃((⊂'coltitles')∊⎕C↑¨d.props)0)
      ∆,←⊂'Items'({0=≢⍵:⍵ ⋄ 2≠⍴⍴⍵:⍵ ⋄ ⍵[;0]}d.default)
      :If 2=⍴⍴d.default
      :AndIf 1<1⊃⍴d.default
          ∆,←⊂'ReportInfo'(0 1↓d.default)
      :EndIf
      ∆,←⊂'View' 'Report'
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      listView←p.ctrl.⎕NEW'ListView'∆
      listView.Size←10⌈2↑d.length
      listView.Size[0]←CalcListViewHeight listView d.length
      ⍎'n.',d.name,'←listView'
      listView.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n listView
      :If 2=⍴⍴d.default
          {}{listView.SetColSize ⍵ ¯3}¨⍳1⊃⍴d.default
          {}listView.SetColSize(1⊃⍴d.default)0
      :Else
          {}listView.SetColSize 0 ¯3
          {}listView.SetColSize 1 0
      :EndIf
      :If 0<+/listView.SelItems  ⍝ Might have been set via "Props"
          {}##.SelAndProcess.SetFocusTo listView(¯1↑⍸listView.SelItems)
      :EndIf
      listView.∆DataType←##.Enums.InputDataTypes.ListView
      listView.∆Default←d.default
      listView.∆MyName←d.name
      listView.∆LastSelItems←⍬
      listView.⎕DF d.name
    ∇

    ∇ {notepad}←AddNotepad(d n p lo);∆;size;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'WantsReturn' 1
      ∆,←⊂'VScroll' ¯1
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Text'd.default
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'Posn'p.startAt
      ∆,←⊂'Style' 'Multi'
      ∆,←⊂'Active'd.active
      notepad←p.ctrl.⎕NEW'Edit'∆
      ⍎'n.',d.name,'←notepad'
      notepad.Posn←p.startAt
      notepad.Size←10⌈d.length
      notepad.Size[0]←CalcNotepadHeight notepad d.length
      p.startAt[0]←n.∆Hgap CalcNextPosn n notepad
      notepad.onGotFocus←'OnGotFocus'
      notepad.onLostFocus←'OnLostFocus'
      notepad.onChange←'OnChange'
      notepad.onKeyPress←'OnKeyPress'
      notepad.∆DataType←##.Enums.InputDataTypes.Notepad
      notepad.∆Default←d.default
      notepad.∆MyName←d.name
      notepad.⎕DF d.name
    ∇

    ∇ {edit}←AddNumeric(d n p lo);∆;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'ValidIfEmpty' 1
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'FieldType' 'Numeric'
      :If 0=1↑0⍴d.default
          ∆,←⊂'Value'(1↑d.default)
      :Else
          ('Invalid value in field "',d.name,'"')⎕SIGNAL 11/⍨1≠↑⎕VFI∊d.default
          ∆,←⊂'Value'(1⊃⎕VFI∊d.default)
      :EndIf
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'Active'd.active
      edit←p.ctrl.⎕NEW'Edit'∆
      edit.⎕DF d.name
      ⍎'n.',d.name,'←edit'
      edit.Posn←p.startAt
      CalcBestSizeForEditFieldsAndSetMaxLength edit d.length ##.Enums.InputDefaultLength.Numeric edit.Text
      p.startAt[0]←n.∆Hgap CalcNextPosn n edit
      edit.onGotFocus←'OnGotFocus'
      edit.onLostFocus←'OnLostFocus'
      edit.onChange←'OnChange'
      edit.onKeyPress←'OnKeyPress'
      AddWatchLengthCallback n edit
      edit.∆DataType←##.Enums.InputDataTypes.Numeric
      edit.∆Default←d.default
      edit.∆MyName←d.name
      edit.⎕DF d.name
    ∇

    ∇ {image}←AddImage(d n p lo);∆;data;bitmap;icon;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'Points'p.startAt
      ∆,←d.props
      :If (⊂d.default)∊##.Enums.DialogStyles.∆List[;1]
          data←##.APLGuiIcons.⍎d.default⊃'' 'Query' 'Info' 'Error' 'Warn' 'Stop'
          icon←⎕NEW'Icon'({('Bits'(0⊃⍵))('CMap'(1⊃⍵))('Mask'(2⊃⍵))('KeepBits' 1)}data)
          ∆,←⊂'Picture'icon
      :ElseIf 'file:///'{⍺≡⎕C(≢⍺)↑⍵}d.default
          bitmap←⎕NEW'Bitmap'(⊂'File'((≢'file:///')↓d.default))
          ∆,←⊂'Picture'bitmap
      :ElseIf 9=⎕NC d.default
      :AndIf  ⍝TODO⍝
          ∆,←⊂'Picture'(⍎d.default)
      :Else
          . ⍝Huuh?
      :EndIf
      ∆,←(0≠+/d.length)/⊂'Size'(d.length)
      image←p.ctrl.⎕NEW'Image'∆
      ⍎'n.',d.name,'←image'
      image.Points[0]←p.startAt[0]+(label≡⍬)SmoothVerticalImagePosition p n image
      image.Points[1]←p.startAt[1]
      p.startAt[0]←n.∆Hgap CalcNextPosn n image
      image.onKeyPress←'OnKeyPress'
      image.∆DataType←##.Enums.InputDataTypes.Image
      image.∆Default←⍬
      image.∆MyName←d.name
      image.⎕DF d.name
    ∇

    ∇ {placeHolder}←AddPlaceHolder(d n p lo);∆;placeHollder
      ∆←''
      ∆,←⊂'Visible' 0
      ∆,←d.props
      ∆,←⊂'Active' 0
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      placeHolder←p.ctrl.⎕NEW'Group'∆
      ⍎'n.',d.name,'←placeHolder'
      placeHolder.Size←0⌈(¯1+(↑d.length)×n.∆g.Height),1
      placeHolder.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n placeHolder
      placeHolder.∆DataType←##.Enums.InputDataTypes.PlaceHolder
      placeHolder.∆MyName←d.name
      placeHolder.⎕DF d.name
    ∇

    ∇ {group}←AddRadio(d n p lo);∆;rf2;buffer;buttons;captions
      captions←'⋄'Split d.label
      'Invalid "YesNo" definition'⎕SIGNAL 11/⍨0 1∊⍨≡captions
      :If 1=≢d.default
          d.default←(¯1+≢captions){b←⍺⍴0 ⋄ b[⍵]←1 ⋄ b}d.default
      :EndIf
      d.default←(¯1+≢captions){⍺{⍺⍴⍵}⍣(↑1=≢⍵)⊣⍵},d.default
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Label)
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'Caption'(↑captions)
      group←p.ctrl.⎕NEW'Group'∆
      ⍎'n.',d.name,'←group'
      group.⎕DF d.name
      buttons←AddRadioButtons group d n p(1↓captions)
      group.Size←10 80++⌿⊃(↑¯1↑buttons).(Posn Size)
      group.Size[1]⌈←25+1⊃group.GetTextSize↑captions ⍝ Ensure the Group caption remains visible
      group.Posn←p.startAt
      :If group.Size[0]>n.∆g.Height
          group.Posn[0]+←⌊0.5×(n.∆g.Height×⌈group.Size[0]÷n.∆g.Height)-group.Size[0]   ⍝TODO⍝  What is this good for? Does not make sense to me!
      :EndIf
      group.Posn[1]+←5
      p.startAt[0]←n.∆Hgap CalcNextPosn n group
      group.onGotFocus←'OnGotFocus'
      group.onLostFocus←'OnLostFocus'
      group.∆DataType←##.Enums.InputDataTypes.Radio
      :If 0≠≢buffer←(({'States'∘≡¨↑¨⍵}d.props)/d.props)
          group.∆Default←1⊃↑buffer
          group.∆Default{⍵.State←⍺}¨⎕WN group
      :Else
          group.∆Default←(≢buttons)↑1
      :EndIf
      group.∆MyName←d.name
    ∇

    ∇ buttons←AddRadioButtons(parent d n p captions);∆;∆2;i;posn;button;rf
      buttons←⍬
      ∆←⊂'Style' 'Radio'
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      posn←⌈n.(2.5 1×∆Vgap ∆Hgap)
      :For i :In ⍳≢d.default
          ∆2←∆
          ∆2,←⊂'Posn'posn
          ∆2,←⊂'Caption'(i⊃captions)
          ∆2,←⊂'State'(i⊃d.default)
          button←parent.⎕NEW'Button'∆2
          rf←⍎'n.',d.name,'_',(¯2↑'00',⍕i),'←button'
          rf.⎕DF d.name,'_',¯2↑'00',⍕i
          posn[0]+←↑button.Size
          buttons,←button
      :EndFor
    ∇

    ∇ {spinner}←AddSpinner(d n p lo);label;∆;longest
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'FieldType' 'Numeric'
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Items'd.default
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      spinner←p.ctrl.⎕NEW'Spinner'∆
      ⍎'n.',d.name,'←spinner'
      longest←(GetLargestTextFrom spinner)
      longest,←3⍴'W'  ⍝TODO⍝  We add 3 for the spinner but we want to know exactly! Does font size make a difference regarding the spinner?
      CalcBestSizeForEditFieldsAndSetMaxLength spinner(↑d.length)##.Enums.InputDefaultLength.Spinner longest
      spinner.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n spinner
      AddWatchLengthCallback n spinner
      spinner.onGotFocus←'OnGotFocus'
      spinner.onLostFocus←'OnLostFocus'
      spinner.onKeyPress←'OnKeyPress'
      spinner.onChange←'OnChange'
      spinner.∆DataType←##.Enums.InputDataTypes.Spinner
      spinner.∆Default←d.default
      spinner.∆MyName←d.name
      spinner.⎕DF d.name
    ∇

    ∇ {time}←AddTime(d n p lo);∆;label
      label←CreateLabel n p d lo
      p.startAt[0]+←label.Size[0]
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←d.props
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'HasCheckBox' 0
      ∆,←⊂'FieldType' 'Time'
      time←p.ctrl.⎕NEW'DateTimePicker'∆
      ⍎'n.',d.name,'←time'
      time.Posn←p.startAt
      p.startAt[0]←n.∆Hgap CalcNextPosn n time
      time.DateTime←d.name ConvertTime d.default
      time.onGotFocus←'OnGotFocus'
      time.onLostFocus←'OnLostFocus'
      time.onKeyPress←'OnKeyPress'
      time.∆DataType←##.Enums.InputDataTypes.Time
      time.∆Default←d.default
      time.∆MyName←d.name
      time.⎕DF d.name
    ∇

    :Section YesNo

    ∇ {yesNo}←AddYesNo(d n p lo);∆
      :If '⋄'∊d.label
          yesNo←AddMultipleYesdNo(d n p lo)
      :Else
          yesNo←AddSingleYesdNo(d n p lo)
      :EndIf
    ∇

    ∇ yesNo←AddSingleYesdNo(d n p lo);∆
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Label)
      ∆,←d.props
      ∆,←⊂'Style' 'Check'
      ∆,←⊂'State'd.default
      ∆,←⊂'Caption'd.label
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      yesNo←p.ctrl.⎕NEW'Button'∆
      ⍎'n.',d.name,'←yesNo'
      yesNo.Posn[0]←p.startAt[0]
      yesNo.Posn[1]←p.startAt[1]
      p.startAt[0]←n.∆Hgap CalcNextPosn n yesNo
      n SetCallbacksForYesNo yesNo
      yesNo.∆DataType←##.Enums.InputDataTypes.YesNo
      yesNo.∆Default←d.default
      yesNo.∆MyName←d.name
      yesNo.⎕DF d.name
    ∇

    ∇ group←AddMultipleYesdNo(d n p lo);∆;checkboxes;captions
      captions←'⋄'Split d.label
      :If 1<≢d.default
      :AndIf (≢captions)<1+≢d.default
          captions←(⊂Replace_ByBlank d.name),captions
      :EndIf
      d.default←(¯1+≢captions){⍺{⍺⍴⍵}⍣(↑1=≢⍵)⊣⍵},d.default
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Label)
      ∆,←⊂'Active'd.active
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'Caption'(↑captions)
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Label)
      group←p.ctrl.⎕NEW'Group'∆
      ⍎'n.',d.name,'←group'
      group.∆MyName←d.name
      group.∆DataType←##.Enums.InputDataTypes.YesNo
      checkboxes←AddCheckboxesToGroup group n d(1↓captions)
      group.∆Default←checkboxes.State←d.default
      group.Size←10 20+⌈⌿⊃{+⌿⊃⍵}¨checkboxes.(Posn Size)
      group.Size[1]⌈←25+1⊃group.GetTextSize group.Caption
      group.Posn←p.startAt
      group.Posn[0]←p.startAt[0]+1 SmoothVerticalImagePosition p n group
      p.startAt[0]←CalcNextPosn n group
    ∇

    ∇ buttons←AddCheckboxesToGroup(rf n d captions);i;∆;posn;button
      posn←20 10
      buttons←⍬
      :For i :In ⍳≢d.default
          ∆←''
          ∆,←⊂'Style' 'Check'
          ∆,←⊂'Caption'(i⊃captions)
          ∆,←⊂'Attach'(4⍴'Top' 'Left')
          ∆,←⊂'Posn'posn
          ∆,←⊂'State'(i⊃d.default)
          button←rf.⎕NEW'Button'∆
          ⍎'n.',d.name,'_check_',(¯2↑'00',⍕i),'←button'
          button.⎕DF d.name
          button.∆DataType←E.YesNo
          n SetCallbacksForYesNo button
          posn[0]+←button.Size[0]
          buttons,←button
      :EndFor
    ∇

      GetFromProps←{
    ⍝ ⍵ is something like (⊂'States' (1 2)) or (('States' (1 0))('MaxLength' 10))
    ⍝ ⍺ is a name (simple text vector.
    ⍝ Returns just the value or empty if there is no such thing.
          0=≢props←,⍵:⍬
          name←⊂⍺
          ~name∊↑¨props:⍬
          1⊃((↑¨props)⍳name)⊃props
      }

    ∇ {r}←n SetCallbacksForYesNo rf
      r←⍬
      rf.onGotFocus←'OnGotFocus'
      rf.onLostFocus←'OnLostFocus'
      rf.onKeyPress←'OnKeyPress'
      :If 0≠≢n.∆parms.onChange
          rf.onSelect←'OnChange'
      :EndIf
    ∇

    :EndSection ⍝ YesNo

    :EndSection ⍝ CreateControls

    :Section Private

      GetAllUserDefinedCallbacks←{
          n←⍵
          n.∆parms.(onChange onHelp onInitial onInitialMsg onKeyPress onOkay onPushButton)
      }

    ∇ n←AdjustSize n;list;sf;bottomRight;newSize;imageList;imagePosnAndSize
      :Access Public Shared
      list←n.∆GetRefs''
      list←(~list.Type∊'Vars' 'TabControl' 'TabButton' 'SubForm' 'TipField' 'Font')/list
      list~←n.(∆buttons,∆Form,StatusField1,Statusbar)
      :If 0<n.⎕NC'Progressbar'
          list~←n.Progressbar
      :EndIf
      :If 0=≢imageList←GetAllImagesFrom n
          imagePosnAndSize←⍬
      :Else
          imagePosnAndSize←GetPosnAndSize imageList
      :EndIf
      sf←↑{⍵[;0]}n.∆List'SubForm'
      list~←sf
      bottomRight←n.(3 1×∆Vgap ∆Hgap)+↑⌈⌿⊃+/¨GetPosnAndSize list
      :If 0<n.⎕NC'_SubForm'
          bottomRight+←n._SubForm.Posn
      :EndIf
      newSize←bottomRight
      :If ~0=≢n.∆buttons
          newSize[0]+←(2×n.∆Vgap)+n.∆Form.Size[0]-↑n.Btn_00.Posn
          newSize[1]⌈←(↑+/1↓¨n.∆buttons.Size)+(n.∆Hgap×1+≢n.∆buttons) ⍝ Minimum: the buttons must be visible
      :EndIf
      :If 0<n.∆g.NoOfTabs
          newSize[0]+←n.∆TabButtons[0].Size[0]
          newSize[1]+←2×1⊃(↑(n.∆List'SubForm')[;0]).Posn
      :EndIf
      :If ~0=≢∊n.∆parms.size
          :If 0≠≢↑n.∆parms.size
          :AndIf ∨/(↑n.∆parms.size)>newSize[0]
              :If 0≠≢↑n.∆parms.size
              :AndIf newSize[0]<↑n.∆parms.size
                  newSize[0]←↑n.∆parms.size
              :EndIf
          :EndIf
          :If 0≠≢↑1↓n.∆parms.size
          :AndIf newSize[1]<↑1↓n.∆parms.size
              newSize[1]←↑1↓n.∆parms.size
          :EndIf
      :EndIf
      :If 0≠≢∊n.∆parms.minSize
          :If 0≠≢0⊃n.∆parms.minSize
              newSize[0]⌈←n.∆parms.minSize[0]
          :EndIf
          :If 0≠≢1⊃n.∆parms.minSize
              newSize[1]⌈←n.∆parms.minSize[1]
          :EndIf
      :EndIf
      2 ⎕NQ n.∆Form'Configure',(n.∆Form.Posn),newSize
      :If 0≠≢imageList
          imageList SetPointsAndSizeInImage¨imagePosnAndSize
      :EndIf
    ∇


    ∇ {r}←ExecOnInitial n;parent;fns
    ⍝ Calls the user-defined callback `onInitial` after all the controls have been created but
    ⍝ before ay adjustments to size, posn or the like are made.
      r←n.∆parms.onInitial ExecOnInitial_ n
    ∇

    ∇ {r}←ExecOnInitialMsg n;parent;fns
    ⍝ Calls the user-defined callback `onInitialMsg` after the Form has been created and ajusted.
      r←n.∆parms.onInitialMsg ExecOnInitial_ n
    ∇

    ∇ {r}←callbackName ExecOnInitial_ n;parent;fns
      r←⍬
      :If 0≠≢callbackName
          :If 1=≡callbackName
              parent←↑{⍵~↑⍵}⎕RSI
              fns←parent⍎callbackName
          :Else
              parent←↑callbackName
              {}⎕DL 0.01
              fns←parent⍎1⊃callbackName
          :EndIf
          :If FunctionReturnsResult parent(1⊃callbackName)
              {}fns n
          :Else
              fns n
          :EndIf
      :EndIf
    ∇

    ∇ {n}←AdjustListViewAndNotepad n;listViews;notepads
      :If 0≠≢listViews←(n.∆g.defMat[;I.DataType]=##.Enums.InputDataTypes.ListView)⌿n.∆g.defMat[;I.ControlName]
          n AdjustListViewSize¨n⍎¨listViews
      :EndIf
      :If 0≠≢notepads←(n.∆g.defMat[;I.DataType]=##.Enums.InputDataTypes.Notepad)⌿n.∆g.defMat[;I.ControlName]
          n AdjustNotepadSize¨n⍎¨notepads
      :EndIf
    ∇

    ∇ {r}←SelectFirstTab n;name
      r←⍬
      :If E.Tab∊n.∆g.defMat[;I.DataType]
          name←↑n.∆g.defMat[n.∆g.defMat[;I.DataType]⍳E.Tab;I.ControlName]
          n.∆g.LastTabWas←n.⍎name
          2 ⎕NQ n.∆g.LastTabWas'Select'
      :EndIf
    ∇

    ∇ {parms}←CheckCallbacks parms
      parms.onChange←'onChange'CheckUserCallback_ parms.onChange
      parms.onHelp←'onHelp'CheckUserCallback_ parms.onHelp
      parms.onInitial←'onInitial'CheckUserCallback_ parms.onInitial
      parms.onKeyPress←'onKeyPress'CheckUserCallback_ parms.onKeyPress
      parms.onOkay←'onOkay'CheckUserCallback_ parms.onOkay
      parms.onPushButton←'onPushButton'CheckUserCallback_ parms.onPushButton
    ∇

    ∇ parms←ParmsGymnastics(parms defMat);bool;buffer
      :If 0≠≢parms
          parms←CheckParmsForProgressbarAndStatusbar parms
          parms.watchLength←1=↑∊parms.watchLength
          :If 0≠≢parms.focus
              'Has invalid value: parameter "focus"'⎕SIGNAL 11/⍨~(⊂parms.focus)∊defMat[;0]
          :EndIf
          :If ~IsDevelopment
              parms.debug←0
          :EndIf
          :If ¯1≡parms.menubar
              parms.menubar←GetDefaultMenubar parms.debug
          :EndIf
      :EndIf
    ∇

      CountTabsInDefMat←{
      ⍝ ⍵ is a definition matrix
          dataTypes←⍵[;##.Enums.DefMatIndices.DataType]
          +/##.Enums.InputDataTypes.Tab=dataTypes
      }

      SplitDefMatAtTabs←{
          defMat←⍵
          bool←##.Enums.InputDataTypes.Tab=defMat[;##.Enums.DefMatIndices.DataType]
          bool{⎕ML←0 ⋄ ⍺⊂[0]⍵}defMat
      }

      Replace_ByBlank←{
          0=+/b←'_'=w←⍵:w
          (b/w)←' '
          w
      }

      GetSubFormsOfTabs←{
      ⍝ Returns list of sub-forms in the order defined by the Tabs
          n←⍵
          n.∆TabButtons.TabObj
      }

      GetResults←{
     ⍝ Collects the result of the users efforts for all controls defined in `defMat`.
          n←⍵
          bool←~n.∆g.defMat[;##.Enums.DefMatIndices.DataType]∊##.Enums.InputDataTypes.(Button Label Tab Image PlaceHolder)
          0=≢result←bool⌿n.∆g.defMat[;0]:0 2⍴''
          result←result,[0.5]GetResult¨n.⍎¨result
          result
      }

    ∇ r←GetResult ctrl;DT
     ⍝ Collects the data of a single control
      DT←##.Enums.InputDataTypes
      r←''
      :If 0<ctrl.⎕NC'∆DataType'
          :Select ctrl.∆DataType
          :CaseList DT.Character DT.Notepad DT.Password
              r←ctrl.Text
          :Case DT.Currency
              r←↑1↑ctrl.Value
              r←(10*ctrl.Decimals){(⌊0.5+⍺×⍵)÷⍺}r
          :Case DT.Date
              r←GetDateResult ctrl
          :Case DT.DropDown
              r←ctrl.SelItems
          :Case DT.DropEdit
              :If 0=≢ctrl.Text
                  r←↑ctrl.(SelItems/Items)
              :Else
                  r←ctrl.Text
              :EndIf
          :Case DT.ListView
              r←ctrl.SelItems
          :Case DT.Numeric
              r←↑1↑ctrl.Value
          :Case DT.Radio
              r←{⍵.State}⎕WN ctrl
          :Case DT.Spinner
              :If ctrl.FieldType≡'Char'
                  r←ctrl.Text
              :Else
                  r←↑ctrl.Value
              :EndIf
          :Case DT.Time
              r←GetTimeResult ctrl
          :Case DT.YesNo
              :If 'Group'≡ctrl.Type
                  r←{⍵.State}⎕WN ctrl
              :Else
                  r←ctrl.State
              :EndIf
          :CaseList DT.(Image Button Tab Label PlaceHolder URL)
          ⍝ Those require no action
          :Else
              . ⍝ Huuh?!
          :EndSelect
      :Else
          r←''
      :EndIf
    ∇

    ∇ r←GetDateResult ctrl
      :If (≢ctrl.∆Default)∊3 6 7            ⍝ Timestamp?
          r←3↑2 ⎕NQ #'IDNToDate'(↑ctrl.DateTime)
      :ElseIf 1=≢ctrl.∆Default
          r←100⊥3↑2 ⎕NQ #'IDNToDate'(↑ctrl.DateTime)
      :ElseIf ' '=1↑0⍴ctrl.∆Default
          r←3 FormatDateTime 3↑2 ⎕NQ #'IDNToDate'(↑ctrl.DateTime)
      :Else
          . ⍝ Huuh?!
      :EndIf
    ∇

    ∇ r←GetTimeResult ctrl
      :If 645=⎕DR ctrl.∆Default
          r←1000000÷⍨⌊1000000×1⊃0 1⊤ConvertIdnAndTime ctrl.DateTime
      :ElseIf 1=≢ctrl.∆Default
          r←24 60 60⊥1↓ctrl.DateTime
      :ElseIf 163=⎕DR ctrl.∆Default
      :AndIf (≢ctrl.∆Default)∊6 7
          r←(3↑ctrl.∆Default),(1↓ctrl.DateTime),6↓ctrl.∆Default
      :ElseIf ' '=1↑0⍴ctrl.∆Default
          r←¯8↑FormatDateTime(3↑⎕TS),1↓ctrl.DateTime
      :ElseIf 3=≢ctrl.∆Default
      :OrIf 0=≢ctrl.∆Default
          r←1↓ctrl.DateTime
      :Else
          .⍝ Huuh?!
      :EndIf
    ∇

    ∇ {r}←n SelectTab key;T;I;currentTab;nextTab
      r←⍬
      (I T)←##.Enums.(DefMatIndices InputDataTypes)
      currentTab←n.∆TabButtons.State⍳1
      :If 'TB'≡key
          nextTab←↑1↓currentTab⌽n.∆TabButtons
      :ElseIf 'BT'≡key
          nextTab←↑¯1↑currentTab⌽n.∆TabButtons
      :Else
          . ⍝ Huuh?!
      :EndIf
      2 ⎕NQ nextTab'Select'
    ∇

    ∇ d←GetDefAsNamespace(n row)
     ⍝ ⍵ is a definitions matrix
     ⍝ Returns a namespace with variables
      d←⎕NS''
      d.(name label default dataType length active column)←row
      :If d.dataType=##.Enums.InputDataTypes.Label
          :If 0=≢d.label
              d.label←d.default
          :ElseIf 0=≢d.default
              d.default←d.label
          :EndIf
      :EndIf
      d.props←''
      :If 0≠≢n.∆parms.props
      :AndIf (⊂d.name)∊n.∆parms.props[;0]
          d.props←d.name{1⊃⍵[⍵[;0]⍳⊂⍺;]}n.∆parms.props
      :EndIf
    ∇

    ∇ {label}←CreateLabel(n p d lo);∆;flag
    ⍝ Creates a label and returns it. It also assigns the label
    ⍝ to its designated name within the "n" namespace.
    ⍝ However, if d.label is empty the lable will be invisible
    ⍝ and inactive, and it will not be assigned to the n namespace.
    ⍝ The label is always returned.
    ⍝ This function is designed to create labels as part of other data
    ⍝ types but *not* as the data type "Label" - see AddLabel for that.
      flag←0≠≢d.label
      label←⍬
      ∆←''
      ∆,←⊂'Caption'd.label
      ∆,←⊂'Posn'(p.startAt+0 2)
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Label)
      ∆,←⊂'Attach'(4⍴'Top' 'Left')
      ∆,←⊂'Visible'flag
      ∆,←⊂'Active'flag
      label←p.ctrl.⎕NEW'Label'∆
      ⍎flag/'n.',d.name,'_Label←label'
      ⍝Done
    ∇

    ∇ r←name ConvertDateTime val;val2
    ⍝ "val" is a Date. It can be...
    ⍝ * an integer (like 20151029).
    ⍝ * a vector of integers of length 3, 6 or 7 (like ⎕TS).
    ⍝ * a character vector like '2015-10-29'.
    ⍝ Returns a value that can be used for setting `DateTime` in a `DateTimePicker`.
      :If ' '=1↑0⍴val
          :If (10=⍴val)∧(2='-'+.=val)∧8=+/val∊⎕D    ⍝ Something like '2015-02-02'
              r←(2 ⎕NQ'#' 'DateToIdn'({↑↑(//)⎕VFI ⍵}¨'-'Split val)),3⍴0
          :Else
              ('Data for "',name,'" (Date) is invalid')⎕SIGNAL 11
          :EndIf
      :Else
          :If 1=≢val                   ⍝ Somethingm like 20150911
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑⎕TS)),24 60 60⊤val
          :ElseIf (≢val)∊3 6 7          ⍝ Something like ⎕TS
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑val)),3⍴0
          :Else
              ('Data for "',name,'" (Date) is invalid')⎕SIGNAL 11
          :EndIf
      :EndIf
    ∇

      ConvertIdnAndTime←{
          (100⊥3↑2 ⎕NQ'#' 'IDNToDate'(↑⍵))+(100⊥1↓⍵)÷1000000
      }

    ∇ r←name ConvertTime val;val2
    ⍝ Takes one of:
    ⍝ * An integer (like 235959)
    ⍝ * A float (like 0.235959)
    ⍝ * A text vector like '03:04:05'
    ⍝ * A timestamp like 3 4 5
    ⍝ * Empty (defaults to "now" as timestamp.
    ⍝ Returns an integer vector of length four: (IDN,h,m,s)
    ⍝ with IDN being from today.
    ⍝ Returns a value that can be used for setting `DateTime` in a `DateTimePicker`
    ⍝ which is why the IDN is added.
      :If ' '=1↑0⍴val
          :If 0=≢val
              val←¯8↑FormatDateTime ⎕TS
          :EndIf
          :If (8=≢val)∧(2=':'+.=val)∧6=+/val∊⎕D
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑⎕TS)),{↑↑(//)⎕VFI ⍵}¨':'Split val
          :Else
              ('Data for "',name,'" (Time) is invalid')⎕SIGNAL 11
          :EndIf
      :Else
          :If 1=≢val
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑⎕TS)),{↑↑(//)⎕VFI ⍵}¨{1 1 2 2 3 3⊂¯6↑'0',⍕⌊1000000×⍵}val
          :ElseIf (≢val)∊6 7
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑val)),3↑3↓val
          :ElseIf 3=≢val
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑⎕TS)),val
          :ElseIf 0∊≢val
              r←(2 ⎕NQ'#' 'DateToIdn'(3↑⎕TS)),3↑3↓⎕TS
          :Else
              ('Data for "',name,'" (Time) is invalid')⎕SIGNAL 11
          :EndIf
      :EndIf
    ∇

    ∇ n←CreateForm(globalParms parms);parms2
      parms2←CopyNamespace parms
      parms2.(sysMenu maxButton minButton)←1
      parms2.initialVgap←parms.initialVgap
      parms2.parmType←'StdForm'
      parms2.size←parms2.minSize←⍬ ⍬
      parms2.statusbarMessage←''
      parms2.namePrefix←'_'
      parms2.sizeable←0
      parms2.onOkay←'OnOkay'
      parms2.onCancel←'OnCancel'
      parms2.maxButton←0
      parms2.icon←parms.icon{0=≢⍺:⍵ ⋄ ⍺}globalParms.icon
      parms2.testMode←globalParms.testMode{⍺∨⍵}parms.testMode
      parms2.parent←parms.parent
      parms2.visible←0
      parms.regKey2←''
      n←##.StdForm.Create globalParms parms2
      'parms2'CopyNamespace parms   ⍝ Yes, this IS needed!
      n.∆Form.⎕WS'Event'QuitEvent 1
      n.∆Form.onClose←'OnClose'
      ⍎'n.∆Form.on',(⍕DebugContextMenu),'←''OnShowDebugContextMenu'''
      ⍎'n.∆Form.on',(⍕ShowMsgEvent),'←''OnShowMsg'''
      n.∆Form.onGotFocus←'OnFormGotFocus'
    ∇

    ∇ n←SetGlobalVars(n defMat)
      n.∆g←⎕NS''
      n.∆g.FieldIsOkay←1
      n.∆g.defMat←defMat
      n.∆g.NoOfTabs←CountTabsInDefMat defMat
      n.∆g.ShowGrid←0
      n.∆g.MagicGridLabels←⍬
      n.∆g.Cancelled←0          ⍝ Indicates that the user has pressed the "Cancel" button
      n.∆g.ChangeRejected←0     ⍝ May indicate that the user-defined OnChnage callback has refused a change (OK button!)
      n.∆g.RefuseTabChange←0    ⍝ Used to prevent a Tab change in case the focus comes back from another application
    ∇

    ∇ defMat←parms CheckDefMat defMat;buffer;flag;bool;I;b
    ⍝ Perform a couple of checks on the definition matrix,
    ⍝ We have to make sure that common traps are avoided and
    ⍝ we get a decent definition.
      I←##.Enums.DefMatIndices
      :If 7≠1⊃⍴defMat
          'Definition matrix has too many columns '⎕SIGNAL 11
      :ElseIf 0=≢defMat
          'Definition matrix has invalid shape: at least one row and 5-8 columns are required'⎕SIGNAL 11
      :ElseIf 0=CountTabsInDefMat defMat
          :If 1≠≢∪defMat[;I.Column]
              flag←~∧/2≤/2+/↑¨defMat[;I.Column]
              'Invalid: column definition in defMat'⎕SIGNAL flag/11
          :EndIf
      :Else
          buffer←SplitDefMatAtTabs defMat
          flag←∨/{~∧/2≤/2+/↑¨⍵}¨{⍵[;##.Enums.DefMatIndices.Column]}¨buffer
          'Invalid: column definition in defMat'⎕SIGNAL flag/11
      :EndIf
      'Invalid names in the definition matrix'⎕SIGNAL 11/⍨0≠(⎕NS''){↑⍺.⎕NC ⍵}¨defMat[;0]~¨'&'
      'Names in the definition matrix are not unqiue'⎕SIGNAL 11/⍨{(≢⍵)>≢∪⍵}defMat[;0]
      :If 0<+/bool←defMat[;I.DataType]∊##.Enums.InputDataTypes.(ListView Notepad)
          '"Length" must not be 0 for "ListView" and "Notepad"'⎕SIGNAL 11/⍨0∊¨bool⌿defMat[;I.Length]
      :EndIf
      :If 0<+/bool←defMat[;I.DataType]=##.Enums.InputDataTypes.Spinner
          'The list of a spinner must be numeric'⎕SIGNAL 11/⍨0≠1↑0⍴∊bool/defMat[;I.Default]
      :EndIf
      :If 0<+/b←~defMat[;I.DataType]∊##.Enums.InputDataTypes.(Image)
          (b⌿defMat[;I.Label])←Replace_ByBlank∘↑¨{0=≢⍵:⍺ ⋄ ⍵}/¨↓b⌿defMat[;I.(ControlName Label)]
      :EndIf
      defMat[;I.ControlName]←defMat[;I.ControlName]~¨'&'
      :If parms.appendColon
      :AndIf 0<+/b←~defMat[;I.DataType]∊##.Enums.InputDataTypes.(Tab Button Image YesNo Radio)
          b∧←b\~(¯1↑¨b⌿defMat[;I.Label])∊'.?!,;'
          (b⌿defMat[;I.Label])←{⍵,(':'≠¯1↑⍵)/':'}¨b⌿defMat[;I.Label]
      :EndIf
     ⍝Done
    ∇

    ∇ defMat←BlowUpDefMat defMat
    ⍝ The user may specify as little as 4 columns as the absolute minimum, but we need 7,
    ⍝ so we blow it up and use decent defaults.
      :If 4=1⊃⍴defMat
          defMat,←⊂0    ⍝ Length/rows/columns
      :EndIf
      :If 5=1⊃⍴defMat   ⍝ Active
          defMat,←⊂1
      :EndIf
      :If 6=1⊃⍴defMat   ⍝ Column
          defMat,←⊂1
      :EndIf
    ∇

    ∇ r←GetHeight n;label;∆;edit
    ⍝ Calculates the height of a row in the `Input` grid.
    ⍝ Is size[0] of label + distance + size[0] of edit + vGap
      ∆←''
      ∆,←⊂'Caption' 'W'
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Label)
      ∆,←⊂'Visible' 0
      label←n.∆Form.⎕NEW'Label'∆
      r←label.Size[0]
      ∆←''
      ∆,←⊂'Font'(n GetParm ##.Enums.Fonts.Input)
      ∆,←⊂'Text' 'W'
      ∆,←⊂'Visible' 0
      edit←n.∆Form.⎕NEW'Edit'∆
      edit.Posn←r,0
      edit.Size←16 10+edit.GetTextSize 1⍴'W'
      r←r+edit.Size[0]+n.∆Vgap
      (edit label).Close
    ∇

    ∇ r←{add}CalcNextPosn(n ctrl)
    ⍝ ↓↓↓ Shall we change strategy and position every column idenepndently of each other?
      add←{0<⎕NC ⍵:⍎⍵ ⋄ 0}'add'
      :If (,0)≢,ctrl
          :If 'Image'≡ctrl.Type
              :If 0=≢∊ctrl.Size
                  r←add+n.∆g.Height×⌈(↑+⌿⊃(↑¯1↑ctrl).(Points Picture.Size))÷n.∆g.Height
              :Else
                  r←add+n.∆g.Height×⌈(↑+⌿⊃(↑¯1↑ctrl).(Points Size))÷n.∆g.Height
              :EndIf
          :Else
              r←add+↑+⌿⊃ctrl.(Posn Size)
          :EndIf
      :Else
          r←n.∆Hgap
      :EndIf
    ∇

    ∇ {r}←CalcBestSizeForEditFieldsAndSetMaxLength(rf length minSize text);corr
    ⍝ "rf" is one of: Enums.InputDataTypes.(Character Numeric Currency DropDown DropEdit Spinner).
    ⍝ "length is what the definition matrix specifies. That might well be zero.
    ⍝ "minSize" is a built-in default which depends on the type of control.
    ⍝ "text" is the contents of the control in question. This is either simple with any
    ⍝  length, including zero, or nested (DropDown & DropEdit).
      r←⍬
      corr←10 25        ⍝ To be added to the height and width
      :If 0=↑length
          rf.Size←corr+↑⌈/rf.GetTextSize¨(minSize⍴'9')text
          rf.MaxLength←minSize
      :Else
          rf.Size←corr+rf.GetTextSize(↑length)⍴'9'
          :If 1=≢length
              rf.MaxLength←↑length
          :ElseIf 2=≢length
              rf.MaxLength←1⊃length
          :EndIf
      :EndIf
    ∇

    ∇ r←GetLargestTextFrom rf;list;lengths
    ⍝ ⍵ is typicaly DropDown or DropEdit or Spinner but NOT a ListView
    ⍝ Takes the items and checks which one occupies the most space. That text is then returned.
    ⍝ Therefore it gets over the fact that "WWW" is more consumptious than "iiii"
      :If 'ListView'≡rf.Type
          :If 'Report'≡rf.View
          :AndIf 0≠≢rf.ReportInfo
              r←{⍵⊃⍨{⍵⍳⌈/⍵}⍴¨⍵}↑¨{⍺,' ',⍵}/¨↓rf.(Items,ReportInfo)
          :Else
              r←{⍵⊃⍨{⍵⍳⌈/⍵}≢¨⍵}rf.Items
          :EndIf
      :ElseIf 1 ⍝rf.Type∊''
          lengths←1⊃¨rf.GetTextSize¨list←⍕¨rf.Items
          r←((,lengths)⍳⌈/lengths)⊃,list
      :Else
          'Invalid right argument'⎕SIGNAL 11
      :EndIf
    ∇

    ∇ {r}←AddWatchLengthCallback(n ctrl)
      r←⍬
      :If n.∆parms.watchLength
          ⍎'ctrl.on',(⍕CheckLengthEvent),'←''OnCheckLength'''
      :EndIf
    ∇

    ∇ {r}←ref SetPointsAndSizeInImage pointSize
    ⍝ This function is used to restore "Points" and "Size" after a resize of the parent form.
    ⍝ Is tricky because the "Size" might be defined on the "Image" itself or on "Image.Picture".
    ⍝ This is necessary because at the time of implementing (2015) Images don't have "Attach".
      :If 0=≢∊ref.Size
          ref.(Points Size)←pointSize
      :Else
          ref.(Points Picture.Size)←pointSize
      :EndIf
    ∇

      GetAllImagesFrom←{
          0=≢list←n.∆List'':⍬
          0=≢list←(list[;1]≡¨⊂'Image')/list[;0]:⍬
          n⍎¨list
      }

      SmoothVerticalImagePosition←{
    ⍝ Tries to position an image (which norally is non-standard in terms of size) somewhere
    ⍝ nice on the magic grid.
    ⍝ Normally no effort is made to change the position in case the size is less than
    ⍝ the standard height of a control but there are exceptions. For example, if
    ⍝ an image does not have a label then it will be smoothed even when it is smaller.
    ⍝ If it has a label it will only be smoothed in case it's bigger.
          ⍺←0
          force←⍺
          (p n image)←⍵
          height←↑1⊃GetPosnAndSize image
          (~force)∧n.∆g.Height>height:0
          ⌊0.5×height-{⍵×⌊height÷⍵}n.∆g.Height
      }

    ∇ {n}←n AdjustListViewSize listView;fac;needed;size;scollbarWidth;scrollbarHeight;row;length
    ⍝ Adjusts the size for a ListView.
    ⍝ Handles all possible situation:
    ⍝ * Axis is set to specific positive value: use that!
    ⍝ * Axis is not set at all: calculate it!
    ⍝ * Axis is set to ¯1: occupy all available space defined by other controls.
    ⍝ "listView" points to the control.
      row←(n⍎¨n.∆g.defMat[;I.ControlName])⍳listView
      length←row⊃n.∆g.defMat[;I.Length]
      :If ¯1∊length
          size←(0,n.∆Hgap)+↑⌈/{+⌿⊃GetPosnAndSize ⍵}¨(↑,/⎕WN¨GetSubFormsOfTabs n)~listView
      :EndIf
      :If (,¯1)≡,↑length
          listView.Size[0]←size[0]-listView.Posn[0]+n.∆Vgap
      :Else
          listView.Size[0]←CalcListViewHeight listView length
      :EndIf
      :If 0≠↑≢1↑1↓length
          :If ¯1=1↑1↓length
              listView.Size[1]←size[1]-listView.Posn[1]+n.∆Hgap
          :Else
              scollbarWidth←30
              :If 0=1↑1↓length
                  listView.Size[1]←scollbarWidth+1⊃listView.GetTextSize GetLargestTextFrom listView
              :Else
                  listView.Size[1]←scollbarWidth+1⊃listView.GetTextSize(1↑1↓length)⍴'9'
              :EndIf
          :EndIf
      :EndIf
    ∇

      CalcListViewHeight←{
          (listView length)←⍵
          ⍝borderHeight←1
          ⍝lineHeight←borderHeight+GetListViewItemHeight listView
          lineHeight←GetListViewItemHeight listView
          fac←(0≥1↑length)⊃(1↑length)(≢listView.Items)
          fac+←0≠≢listView.ColTitles
          needed←fac×lineHeight
          needed
     
          scrollbarHeight←30
          needed+scrollbarHeight
      }

    ∇ {n}←n AdjustNotepadSize notepad;row;length;size;refs
      row←(n⍎¨n.∆g.defMat[;I.ControlName])⍳notepad
      length←row⊃n.∆g.defMat[;I.Length]
      :If ¯1∊length
          :If 0=n.∆g.NoOfTabs
              :If 0≠≢refs←n.∆GetRefs''
              :AndIf 0≠≢refs~←n.∆GetRefs'Notepad'
              :AndIf 0≠≢refs←({6::0 ⋄ 1⊣⍵.Posn}¨refs)/refs
                  size←(0,n.∆Hgap)+↑⌈/{+⌿⊃⍵.(Posn Size)}¨refs
              :Else
                  '"Length" of "Notepad" contains ¯1 but there are no other controls'⎕SIGNAL 11
              :EndIf
          :Else
              size←(0,n.∆Hgap)+↑⌈/{+⌿⊃GetPosnAndSize ⍵}¨(↑,/⎕WN¨GetSubFormsOfTabs n)~notepad
          :EndIf
      :EndIf
      :If ¯1=1↑length
          notepad.Size[0]←size[0]-notepad.Posn[0]+n.∆Vgap
      :Else
          notepad.Size[0]←CalcNotepadHeight notepad length
      :EndIf
      :If ¯1=1↑1↓length
          notepad.Size[1]←size[1]-notepad.Posn[1]+n.∆Hgap
      :Else
          notepad.Size[1]←1⊃notepad.GetTextSize(↑1↓length)⍴'9'
      :EndIf
    ∇

      CalcNotepadHeight←{
          (notepad length)←⍵
          (10⌈↑length)×2+↑notepad.GetTextSize'9'
      }

    ∇ {r}←HandelSelText(rf n);Styles
      r←⍬
      Styles←##.Enums.SelTextStyles
      :If 0 1∊⍨≡rf.Text  ⍝ if simple it is an edit, and "SelTextStyle" is used to determine the way to process "SelText".
          :If 1 1≡rf.SelText
          :OrIf rf.SelText≡2⍴1+≢rf.Text
              :Select n.∆parms.selTextStyle
              :Case Styles.Full
                  rf.SelText←1,1+≢rf.Text
              :Case Styles.End
                  rf.SelText←2⍴1+≢rf.Text
              :Case Styles.Pos1
                  rf.SelText←1 1
              :Case Styles.Restore
                  :If 0<rf.⎕NC'∆LastSelText'
                      rf.SelText←rf.∆LastSelText
                  :EndIf
              :Else
                  .That MUST NOT happen!
              :EndSelect
          :EndIf
      :Else
            ⍝ It is a notepad: we don't temper with the cursor position
      :EndIf
    ∇

    ∇ {r}←ShowOrHideMagicGrid n
    ⍝ Returns 1 when it was toggled on, otherwise 0.
      :If n.∆g.ShowGrid
          n.∆g.MagicGridLabels.Close
          n.∆g.MagicGridLabels←⍬
          r←0
      :Else
          AddMagicGrid n
          r←1
      :EndIf
      n.∆g.ShowGrid←~n.∆g.ShowGrid
    ∇

    ∇ (res mm)←ShowContextMenu n;mm;caption
      mm←⎕NEW⊂'Menu'
      mm.cancel←mm.⎕NEW'MenuItem'(⊂('Caption' 'Cancel'))
      mm.sep1←mm.⎕NEW⊂'Separator'
      caption←(n.∆g.ShowGrid⊃'Show' 'Hide'),' grid'
      mm.showGrid←mm.⎕NEW'MenuItem'(⊂('Caption'caption))
      mm.(cancel showGrid).onSelect←1
      :If 0≠≢res←⎕DQ mm
          res←↑res
      :EndIf
    ∇

    ∇ HandelSelItems(rf n)
      :If rf.∆DataType∊##.Enums.InputDataTypes.(DropDown DropEdit)
          rf.LastSelItems←rf.SelItems
      :EndIf
    ∇

    ∇ r←HandleKeyPressInSpinner(rf key n);i
      r←1
      :If (⊂key)∊'DI' 'DB' 'LC' 'RC'            ⍝ Ignore <Delete>, <??>, <CursorLeft>, <CursorRight>
          r←0
      :ElseIf (⊂key)∊'DC' 'UC' 'DS' 'US' 'LL' 'RL'
          :If 4>i←'DC' 'UC' 'DS' 'US' 'LL' 'RL'⍳⊂key
              rf.Thumb←rf.Limits[0]⌈rf.Limits[1]⌊rf.Thumb+i⊃¯1 1 ¯1 1
          :Else
              rf.Thumb←(i-4)⊃⌽rf.Limits
          :EndIf
      :EndIf
    ∇

    ∇ r←HandleKeyPressInComboxEx(rf key n);i
      r←1
      :If 'DS'≡⊂key                         ⍝ PgDwn
          :If rf.SelItems≢(-≢rf.Items)↑1
              rf.SelItems←¯1⌽rf.SelItems
          :EndIf
          r←0
      :ElseIf 'US'≡⊂key                     ⍝ PgUp
          :If rf.SelItems≢(≢rf.Items)↑1
              rf.SelItems←1⌽rf.SelItems
          :EndIf
          r←0
      :EndIf
    ∇

    ∇ {r}←ExecKeyPressCallback(n msg);parent;fns
      r←1
      :If 0≠≢n.∆parms.onKeyPress
          parent←↑n.∆parms.onKeyPress
          fns←parent⍎1⊃n.∆parms.onKeyPress
          r←n fns msg
      :EndIf
      ⎕NQ(↑msg)CheckLengthEvent
    ∇

    ∇ {r}←CheckParms(parms defMat);bool
      :If 0≠≢parms
          :If 2=parms.⎕NC'props'
              '"props" has an invalid rank'⎕SIGNAL 11/⍨2≠⍴⍴parms.props
          :EndIf
          :If 0∊bool←parms.props[;0]∊defMat[;I.ControlName]
              11 ⎕SIGNAL⍨'"props" carries ',(⍕+/~bool),' invalid control name(s)'
          :EndIf
      :EndIf
    ∇

      GetTabNoFor←{
      ⍝ Takes a control name (⍵) and n (⍺) and returns the Tab number where the control lives on
          n←⍺
          ctrl←n ConvertControlNameToRef ⍵
          row←n.∆g.defMat[;##.Enums.DefMatIndices.ControlName]⍳⊂ctrl.∆MyName
          ¯1++/##.Enums.InputDataTypes.Tab=row↑n.∆g.defMat[;##.Enums.DefMatIndices.DataType]
      }

    ∇ (flag msg)←ExecUserDefinedOnChange(ctrl n);parent;fns;buffer;name
      (parent name)←n.∆parms.onChange
      fns←parent⍎name
      buffer←fns ctrl n
      :If (⊂buffer)∊0 1
          flag←buffer
          msg←''
      :Else
          (flag msg)←buffer
      :EndIf
    ∇

    ∇ n←AddHelpCallback(n parms)
      :If 0≠≢parms.onHelp
          n.∆Help.onSelect←'OnHelp'
      :EndIf
    ∇

      ConvertControlNameToRef←{
      ⍝ ⍵ may be a control name or a ref pointing to a ctrl.
      ⍝ The latter is passed through but the former is converted into a ref.
          n←⍺
          ~(⎕DR ⍵)∊80 82:⍵
          controlName←⍵
          ~(⊂controlName)∊n.∆g.defMat[;I.ControlName]:'Invalid right argument: not a control name'⎕SIGNAL 11
          n⍎controlName
      }

      DoesStatusFieldShowAlarm←{
      ⍝ Checks whether the status field1 shows an alarm message right now. Decided by the background color.
          n←⍵
          n.StatusField1.BCol≢n.∆globalParms.alarmColor
      }

      ShowChangeMsg←{
      ⍝ Check msg and trigger event to show it (must be delayed)
          (n ctrl msg)←⍵
          0=≢msg:⍬              ⍝ No message to be shown? Done!
          1≠≡msg:'Invalid "msg" returned by user-defined "onChange" callback'⎕SIGNAL 11
          ' '≠1↑0⍴msg:'Invalid "msg" returned by user-defined "onChange" callback'⎕SIGNAL 11
          ⍬⊣⎕NQ n.∆Form ShowMsgEvent(ctrl msg)
      }

    ∇ font←CreateLabelFont label;props
    ⍝ In case FCol←→0 0 555 (blue) then the font created is underlined, otherwise it's not.
      :If ~0=≢n.∆parms.fontLabel
          props←'PName' 'Size' 'Fixed' 'Italic' 'Weight'{⍺,[0.5]⍵.⍎¨⍺}n.∆parms.fontLabel
      :ElseIf ~0=≢n.∆globalParms.fontLabel
          props←'PName' 'Size' 'Fixed' 'Italic' 'Weight'{⍺,[0.5]⍵.⍎¨⍺}n.∆globalParms.fontLabel
      :EndIf
      :If label.FCol≡0 0 255
          props⍪←'Underline' 1
          props⍪←'Weight' 600
      :EndIf
      font←⎕NEW'Font'(↓props)
    ∇

    ∇ r←GetUrlSearchPattern
      r←'^<((http|https|ftp|tftp|mailto)://.+?)>$'
    ∇

    :EndSection ⍝ Private

:EndClass
