:Class Menubar
⍝ Use this class to take a simple text definition for a menubar and it's children and
⍝ convert it into GUI controls that will get attached the "parent" which normally is a form.\\
⍝ The `Create` method returns a namespace populated with references pointing to the
⍝ menus and menu items, so manipulating them is easy.\\
⍝ The name "Menubar" is reserved and must not be used for menus or menu items.\\
⍝ Note that this class does not need to be instanciated.\\
⍝ Copyright: Kai Jaeger ⋄ APL Team Ltd ⋄ http://aplteam.com\\

    :Include APLGuiUtils

    (⎕IO ⎕ML)←0 3

    ∇ r←CreateParms
      :Access Public Shared
    ⍝ Returns a parameter namespace with default settings.
      r←##.APLGuiParameterSpace.Create
      r.debug←0
      r.hintObj←¯1
      r.menubarName←'MB'
      r.noDevelopersMenu←0
      ⍝Done
    ∇

    ∇ make
      :Access Public Instance
      :Implements Constructor
      'This class must not be instanciated'⎕SIGNAL APLGuiError
    ∇

    ∇ n←Create(parent definition parms KeyCodesInstance);level;def;refToMB;bool;⎕TRAP
      :Access Public Shared
    ⍝ Create a menubar (and menus, submenus, menuitems...) from a simple text definition.\\
    ⍝ Note that Separators don't have names while Menus and MenuItems must have names.
      parms←{(0=≢⍵):CreateParms ⋄ ⍵}parms
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      'Menu definition is invalid'⎕SIGNAL APLGuiError/⍨1≠⍴⍴definition
      def←Interpret definition
      'Invalid: paramaters - must be a namespace'⎕SIGNAL APLGuiError/⍨9≠⎕NC'parms'
      parms←CheckHintObject parms parent
      n←CreateControls def parms parent
      :If parms.debug
      :AndIf 0=parms.noDevelopersMenu
          n←CreateDevelopmentMode n
      :EndIf
    ∇


    ∇ def←Reformat def;bool;def2;rows;KeyCodesInstance
      :Access Public Shared
    ⍝ Reformat a menu definition properly.
      ⎕TRAP←(APLGuiError'E'('⎕DMX.EM ⎕SIGNAL ',⍕APLGuiError))(0 'N')
      bool←0<≢¨{⍵~' ',⎕TC,⎕UCS 9}¨def
      bool∧←'⍝'≠↑¨##.APLTreeUtils2.DLB def
      def2←bool/def
      KeyCodesInstance←⎕NEW ##.KeyCodes
      def2←Interpret def2
      def2[;3]←{w←⍵ ⋄ ((w=⎕UCS 9)/w)←'=' ⋄ w}¨def2[;3]
      rows←⍸~def2[;4]
      def2[rows;3]←def2[rows;3],⍨¨'~'
      rows←⍸def2[;5]
      def2[rows;3]←def2[rows;3],⍨¨'#'
      rows←⍸def2[;0]≡¨⊂'Menu'
      def2[rows;3]←{'[',⍵,']'}¨def2[rows;3]
      def2[;2]←{'{',⍵,'}'}¨def2[;2]
      def2[;3]←(def2[;1]⍴¨' '),¨def2[;3]
      def2[;8]←'; '∘,¨def2[;8]
      def2[;6]←{' : ',⍵}¨def2[;6]
      rows←⍸def2[;0]≡¨⊂'Separator'
      def2[rows;2 6 8]←⊂''
      def2[rows;3]←⊂'-'
      def2←def2[;3 6 2 8]
      (bool/def)←↓⎕FMT def2
    ∇

    ∇ n←CreateControls(def parms parent);i;lastParent;lastLevel;newParent;rf
      n←##.FormRefNamespace.Create'Menubar'
      n.menubar←parent.⎕NEW⊂'Menubar'
      lastParent←n.menubar
      lastLevel←0
      rf←⍬
      :For i :In ⍳0⊃⍴def
          (lastParent lastLevel rf)←CreateControl parms lastParent lastLevel rf def i
      :EndFor
    ∇

    ∇ n←CreateDevelopmentMode n;m
      n.DevelopersMenu←n.menubar.⎕NEW'Menu'(('Caption' 'Developers')('Align' 'Right'))
      n.DvlpEditCallback←n.DevelopersMenu.⎕NEW'MenuItem'(⊂('Caption' 'Edit callbacks...'))
      n.DvlpEditCallback.onSelect←'OnDvlpEditCallback'
    ∇

    ∇ (lastParent lastLevel rf)←CreateControl(parms lastParent lastLevel rf def rno);type;level;name;caption;active;checked;keyCode;hint;newParent;∆;callback
    ⍝ This function must be called by `CreateControls`; it's not designed to run on its own (`def`, `i`).\\
    ⍝ It refers to a couple of semi-globals and takes only those as an argument which will be modified.
      (type level name caption active checked callback keyCode hint)←def[rno;]
      :If level=lastLevel
          newParent←lastParent
      :Else
          newParent←CalcNewParent def rno
      :EndIf
      :Select type
      :Case 'Menu'
          ∆←('Caption'caption)('Active'active)
          ∆,←((level=0)∧0≠≢hint)/⊂('Hint'hint)
          rf←newParent.⎕NEW'Menu'∆
          ⍎'n.',name,'←rf'
      :Case 'MenuItem'
          ∆←('Caption'caption)('Active'active)('Checked'checked)
          :If 0≠≢hint
          :AndIf 0≢parms.hintObj
              ∆,←⊂'Hint'hint
              ∆,←⊂'HintObj'(parms.hintObj)
          :EndIf
          ∆,←(0≠≢keyCode)/⊂'Accelerator'keyCode
          rf←newParent.⎕NEW'MenuItem'∆
          ⍎'n.',name,'←rf'
          :If 0≠≢callback
              rf.onSelect←callback
          :EndIf
      :Case 'Separator'
          ⍎'n.sep_',(¯2↑'00',⍕rno),'←newParent.⎕NEW⊂''Separator'''
      :EndSelect
      lastParent←newParent
      lastLevel←level
    ∇

    ∇ R←KeyNo Key
    ⍝ "Key" maybe one of ⎕A or ⎕D or "F1", "F2",..."F20" or stuff like
    ⍝ "Ins", "Del", "PgUp", "PgDn", "Home", "End", "Escape", "Enter", "Space".
    ⍝ If "Key" is unknown R will be empty.
    ⍝ Composed strings are allowed, too. Example: "Ctrl+A" as well as "Strg+a".
    ⍝ Other examples: Ctrl+Shift+Q, Ctrl+Shift+Alt+Q.
    ⍝ Note that "A+CTRL" are *not* allowed!
    ⍝ If "Key" is empty a matrix is returned with all valid keywords.
      R←''
      :Trap APLGuiError
          R←KeyCodesInstance.GetKeyCodeFor Key
      :Else
          R←''
      :EndTrap
    ∇

    ∇ r←Interpret def;i;this;type;level;active;checked;hint;callback;caption;keyCode;diff;name;l;p;b
    ⍝ The optinal left argument defaults to 0 meaning that the function does
    ⍝ not try to find the callback. With a 1 as left argument it does try to
    ⍝ find it and signals an error if it fails.
      def←CleanUpMenuDef def
      r←((≢def),9)⍴''
      :For i :In ⍳⍴def
          this←i⊃def
          type←{('-'=1↑⍵):'Separator' ⋄ ('['=↑⍵)⊃'MenuItem' 'Menu'}##.APLTreeUtils2.DLB this
          level←+/∧\' '=this
          this←##.APLTreeUtils2.DLB this
          (caption this)←{w←⌊/⍵⍳':{' ⋄ ('[]'~⍨w↑⍵)(w↓⍵)}this
          caption←##.APLTreeUtils2.DTB caption
          (caption keyCode)←HandleKeyCode caption
          :If '='∊caption
              caption[caption⍳'=']←↑⎕UCS 9
          :EndIf
          (callback this)←GetHandler this
          :If (,'→')≡,callback
              callback←'OnQuit'
          :EndIf
          (name hint)←SplitNameAndHint this
          :If 0=≢name
              :If 'Separator'≡type
                  name←'sep_',⍕i
              :Else
                  :If 'Menu'≡type
                      :If ¯1=⎕NC name←({w←⍵ ⋄ ((' '=w)/w)←'_' ⋄ w}caption~'&#~'),'_Menu'
                          :If 0=≢caption
                              APLGuiError ⎕SIGNAL⍨'<Name> is missing: "',callback,' ',this,'"'
                          :Else
                              APLGuiError ⎕SIGNAL⍨'<Name> is missing: "',caption,'"'
                          :EndIf
                      :EndIf
                  :Else
                      :If 0=≢caption
                          APLGuiError ⎕SIGNAL⍨'<Name> is missing: "',callback,' ',this,'"'
                      :Else
                          APLGuiError ⎕SIGNAL⍨'<Name> is missing: "',caption,'"'
                      :EndIf
                  :EndIf
              :EndIf
          :EndIf
          active←~'~'=↑##.APLTreeUtils2.DLB caption
          checked←'#'=↑##.APLTreeUtils2.DLB caption
          caption←((↑caption)∊'#~')↓caption
          r[i;]←type level name caption active checked callback keyCode hint
      :EndFor
      :If 0≠≢l←{⍵/⍨~(⍳≢⍵)=⍵⍳⍵}r[;2]
          APLGuiError ⎕SIGNAL⍨'Name',((1<≢l)/'s'),' used more than once: ',↑{⍺,',',⍵}/l
      :EndIf
      'The name "Menubar" is reserved and must not be used'⎕SIGNAL APLGuiError/⍨(⊂'Menubar')∊r[;2]
      l←(r[;0]≡¨⊂'MenuItem')⌿r[;2 6]    ⍝ All menu items
      l←(~(⊂,'→')≡¨l[;1])⌿l             ⍝ Remove any line → (= "Quit")
      p←↑⎕RSI~⎕THIS                     ⍝ Where are we called from?
      :If ∨/b←3≠↑∘p.⎕NC¨l[;1]           ⍝ Can we "see" the handlers?
      :AndIf ∨/b←b∧0≠↑∘⍴∘⊂¨l[;1]
          APLGuiError ⎕SIGNAL⍨'No callback found for',((1<+/b)/' these'),': ',↑{⍺,',',⍵}/b⌿l[;0]
      :EndIf
      :If ∨/b←¯1=↑∘⎕NC¨r[;2]
          APLGuiError ⎕SIGNAL⍨'Invalid name:'
      :EndIf
      :If ∨/b←∨/¨(⊂'∆⍙')∊¨r[;2]
          APLGuiError ⎕SIGNAL⍨((1<+/b)⊃'This' 'These'),' contain',((1<+/b)/'s'),' invalid character(s): ',↑{⍺,', ',⍵}/b/r[;2]
      :EndIf
    ∇

    ∇ r←OnQuit msg;n
      :Access Public Shared
      n←##.APLGuiUtils.GetRefTo_n 0⊃msg
      1 ⎕NQ n.∆Form'Close'
      r←1
    ∇

      CleanUpMenuDef←{
      ⍝ Get rid of comments and blanks lines
          definition←⍵
          definition←{(0 1∊⍨≡⍵):⊂,⍵ ⋄ ⍵}definition
          def2←##.APLTreeUtils2.DLB definition
          bool←';'≠↑¨def2
          (definition def2)←bool∘/¨definition def2
          bool←'⍎'=↑¨def2
          (definition def2)←(~bool)∘/¨definition def2
          definition/⍨←'⍝'≠↑¨def2
          definition/⍨←0<≢¨definition
          definition←{(~'⍝'∊⍵):⍵ ⋄ ⍵↑⍨¯1+⍵⍳'⍝'}¨definition
          definition←(0<≢¨definition~¨' ')/definition
          definition~¨⊂⎕TC
      }


      GetHandler←{
      ⍝ Returns the name of a callback (if specified) and the remains of ⍵ as a two-item vector.
          (~':'∊⍵):''⍵
          s←{⍵↓⍨1+⍵⍳':'}⍵
          (h r)←{⍵{(⍵↑⍺)(⍵↓⍺)}⍵⍳'{'}s
          h←FindHandler ##.APLTreeUtils2.DMB h
          h r
      }

      SplitNameAndHint←{
      ⍝ Returns the name part and the remains of ⍵ as a two-item vector.
          s←⍵↑⍨⍵⍳'⍝'
          (~'{'∊s):''⍵
          s←##.APLTreeUtils2.DMB{1↓⍵↑⍨⍵⍳'}'}s
          s(##.APLTreeUtils2.DMB{(~';'∊⍵):1↓⍵ ⋄ ⍵↓⍨1+⍵⍳';'}{⍵↓⍨⍵⍳'}'}⍵)
      }

      HandleKeyCode←{
      ⍝ Returns a key code and the remains of ⍵ as a two-item vector.
          (~'='∊⍵):⍵ ⍬
          sc←1↓⍵↓⍨⍵⍳'='
          code←KeyNo sc
          ##.##.APLTreeUtils2.IsDevelopment∧0=≢code:'Invalid key shortcut'⎕SIGNAL APLGuiError
          ⍵(KeyNo sc)
      }

    GetCaption←{##.APLTreeUtils2.DTB ⍵↑⍨⍵⍳'{'}

      Between←{
      ⍝ (0 0 1 1 1 0 0)←'ab(c)de' Between '()'
          {⍵∨≠\⍵}⍺∊⍵}

      CalcNewParent←{
          (def i)←⍵
          (0=def[i;1]):n.menubar
          (</def[i-1 0;1]):⍎'n.',2⊃def[i-1;]
          (0=def[i;1]):n.menubar
          ⍎'n.',2⊃def[i-{⍵⍳¯1+↑⍵}⌽def[⍳1+i;1];]
      }

      FindHandler←{
          (0=≢⍵~' '):''
          ((,'→')≡,⍵):⍵                 ⍝ Special case: quit
          (('.'∊⍵)∧3=⌊|⎕NC⊂⍵):⍵         ⍝ Already fully qualified? Done!
          cf←{↑⍵~↑⍵}⎕RSI                ⍝ Where have we been called from?
          (3=⌊|cf.⎕NC⊂⍵):(⍕cf),'.',⍵    ⍝ Known in the calling environment?
          ⍵                             ⍝ It might still be available at runtime
      }

      CheckHintObject←{
          (parms parent)←⍵
          (0≡parms.hintObj):parms  ⍝ User has suppressed it
          (¯1≢parms.hintObj):parms ⍝ Then it's supposed to be a ref pointing to the desired hint object
          ⍝ Okay, we need to work it out ourself. We take the first field in the status bar, if there is any
          parms.hintObj←0
          (0=≢sb←'Statusbar'⎕WN parent):parms
          rf←↑sb
          (0=≢l←'StatusField'⎕WN rf):parms
          parms.hintObj←↑l
          parms
      }

      OnDvlpEditCallback←{
          n←GetRefTo_n↑⍵
          m←n.menubar
          list←m.⍎¨m.⎕NL-9
          callbacks←{6::'' ⋄ ↑⍵.onSelect}¨list
          bool←0<≢¨callbacks
          bool∧←' '=≢¨callbacks
          (list callbacks)←bool∘/¨list callbacks
          0=≢list:##.Dialogs.ShowMsg'No callbacks found'
          parms←##.ProcessTool.CreateParms
          parms.centerIn{0=⍵.⎕NC'centerIn':⍺ ⋄ ⍵}←n.∆parms
          parms.addToCaption←'Edit'
          parms.info←'Select the callback you want to edit and then press <Edit>'
          parms.data←list
          parms.colTitles←'Caption' 'Callback' 'Info'
          parms.processBtnCaption←'Edit'
          parms.dblClick←1
          captions←{~(⎕UCS 9)∊⍵:⍵ ⋄ ⍵↑⍨⍵⍳⎕UCS 9}¨list.Caption
          visible←(0<↑∘⎕NC¨callbacks)⊃¨⊂'Invisible' ''
          toBeDisplayed←(captions,[0.6]callbacks),visible
          callback←⎕THIS'OnEditThisCallback'
          _←parms ##.ProcessTool.Run toBeDisplayed callback
          ⍬
      }

    ∇ {r}←OnEditThisCallback(type bool n);callback;row;parms;msg
      :Access Public Shared
      r←0
      :If 0<+/bool
          row←bool⍳1
          callback←1⊃n.List.(Items,ReportInfo)[row;]
          :If 3=⎕NC callback
              :If 14.1≤⍎{⍵/⍨2>+\'.'=⍵}1⊃'#'⎕WG'APLVersion'
                  (⎕ED⍠('EditName' 'Allow'))callback
              :Else
                  ⎕ED callback  ⍝ Prior the version 14.1 we can just edit this one
              :EndIf
              n.List.ReportInfo[row;1]←⊂'Edited'
              ⎕NQ n.List'SetColSize' 2 ¯3
          :Else
              parms←##.Dialogs.CreateParmsForShowMsg
              parms.addToCaption←'Edit failes'
              msg←'Sorry, but you cannot edit an invisible callback'
              n.∆globalParms parms ##.Dialogs.ShowMsg msg
          :EndIf
      :EndIf
    ∇

:Endclass
