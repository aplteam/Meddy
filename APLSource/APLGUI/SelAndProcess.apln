:Namespace SelAndProcess

    ⎕IO←0 ⋄ ⎕ML←3

    ∇ EndNamespace
     
    ∇

    ∇ r←GetSelection n
      :Access Public Shared
      :If n.List.CheckBoxes
          r←12⊃¨n.List GetItemState¨⍳≢n.List.SelItems
      :Else
          r←n.List.SelItems
      :EndIf
    ∇


⍝⍝⍝⍝ Private stuff

      CheckParms←{
          parms←⍵
          1<≡parms.info:'Invalid: "info"; must not be nested'⎕SIGNAL 11
          (¯1≢parms.default)∧~∧/parms.default∊0 1:'Invalid: "default"; must be Boolean'⎕SIGNAL 11
          parms
      }

    ∇ r←OnItemUpInList msg;rf;Else
      r←0
      rf←0⊃msg
      ⎕NQ rf RefreshEvent
      :If 'Single'≡rf.Style
          :If rf.CheckBoxes
              rf.SelItems←(≢rf.SelItems)⍴0
              rf.SelItems[msg[2]]←1
          :EndIf
          {}SetFocusTo rf(msg[2])
      :Else
          :If rf.CheckBoxes
              rf.SelItems[]←0
          :EndIf
          {}SetFocusTo rf(msg[2])
      :EndIf
    ∇

      CreateInfo←{
          n←⍺
          info←⍵
          ∆←''
          ∆,←⊂'Caption'info
          ∆,←⊂'Posn'n.(∆initialVgap ∆Hgap)
          ∆,←⊂'Size'((0=≢info)⊃(⍬(1⊃n.∆Form.GetTextSize'W',info,'W'))(0 0))
          ∆,←⊂'Attach'(4⍴'Top' 'Left')
          n.Info←n.∆Form.⎕NEW'Label'∆
          n
      }

      GetPosnOfList←{
          parms←⍵
          (0=≢⊃parms.info):n.(∆initialVgap ∆Hgap)
          (n.Info.Size[0]+n.∆Vgap+n.Info.Posn[0]),n.∆Hgap
      }

    ∇ {r}←AdjustSizeAndPosn n;needed;corr;posn
        ⍝ Adjusts the size and -if needed- the Posn of the form.
      r←⍬
      needed←95 CalcNeededSize n
      corr←##.APLGuiUtils.RefToWinSys.(+/GetSystemMetrics¨SM_CYMENU SM_CYCAPTION) ⍝ Menu height + caption height
      needed[0]+←corr
      posn←n.∆Form.Posn
      :If 0≠≢↑n.∆parms.posn[0]
          posn[0]←n.∆parms.posn[0]
      :EndIf
      :If 0≠≢↑n.∆parms.posn[1]
          posn[1]←n.∆parms.posn[1]
      :EndIf
      needed[0]←(0≠≢↑n.∆parms.size[0])⊃0⊃¨needed n.∆parms.size
      needed[1]←(0≠≢↑n.∆parms.size[1])⊃1⊃¨needed n.∆parms.size
      :If 0≠≢↑n.∆parms.minSize[0]
          needed[0]⌈←n.∆parms.minSize[0]
      :EndIf
      :If 0≠≢↑n.∆parms.minSize[1]
          needed[1]⌈←n.∆parms.minSize[1]
      :EndIf
      :If 0≠≢↑n.∆parms.posn[1]
          posn[1]←n.∆parms.posn[1]
      :EndIf
      :If 0=≢↑n.∆parms.posn[0]
          posn[0]+←0⊃⌊0.5×n.∆Form.Size-needed
      :EndIf
      :If 0=≢↑n.∆parms.posn[1]
          posn[1]+←1⊃⌊0.5×n.∆Form.Size-needed
      :EndIf
      {}2 ⎕NQ n.∆Form'Configure',posn,needed
    ∇

      SetFocusTo←{
          (rf in)←⍵
          sendmsg←{} ⍝ Prevents `sendmsg` becoming a global function on name class 3.6 with the next line
          _←'sendmsg'⎕NA'I4 USER32|SendMessageW U4 U4 U4 U4'
          hnd←rf.Handle
          b←rf GetItemState in
          b[0 1]←1
          _←2 ⎕NQ rf'SetItemState'in(Power2 b)   ⍝ Don't call the method: bug 10925
          LVM_ENSUREVISIBLE←4115
          _←sendmsg hnd LVM_ENSUREVISIBLE(in-⎕IO)1
          ⍬
      }

      Power2←{
          +/⍵/2*⍳32
      }

    :Section UsedByMenubarClass

      OnCopyList←{
          n←⍺
          cl←⎕NEW'Clipboard' ''
          ⍬⊣cl.Array←n.List.Items
      }

      OnCopyTable←{
          n←⍺
          cl←⎕NEW'Clipboard' ''
          ⍬⊣cl.Array←n.List.(Items,ReportInfo)
      }

    ∇ n OnAdjustHeight msg
      {}AdjustSizeAndPosn n
    ∇

    :EndSection

      GetCurrentItemNo←{
      ⍝ Returns the running number of the item that has currently the focus
          rf←⍵
          1⍳⍨0⊃¨rf GetItemState¨⍳≢rf.Items
      }

      GetItemState←{
      ⍝ ⍺ is ref to the ListView. ⍵ is single item number
          rf←⍺
          ⌽(32⍴2)⊤2 ⎕NQ rf'GetItemState'⍵   ⍝ Don't call the method: bug 10925
      }

      SetItemState←{
          (rf n in)←⍵
          b←rf GetItemState in
          (1⊃b)←0=n.∆parms.checkboxes
          (12⊃b)←n.∆parms.checkboxes
          _←2 ⎕NQ rf'SetItemState'in(Power2 b)   ⍝ Don't call the method: bug 10925
          ⍬
      }

    ∇ size←{maxPercentage}CalcNeededSize n;per;fac;corr;fntObj;btns;available;buf;lineHeight;height;width
        ⍝ Calculates the size of the form.
        ⍝ Takes "size" and "minSize" into account but also restricts the
        ⍝ size to "maxPercentage" if that is defined. "maxPercentage" trumps
        ⍝ "size" while "minSize" trumps "size" only when greater.
        ⍝ Normally "maxPercentage" is specified only at the first call after
        ⍝ a form got created. Purpose is to avoid monster forms to be
        ⍝ created on very large monitors. Later the user might actually ask
        ⍝ for a monster form, so we allow this then.
      fac←1+≢n.List.Items
      lineHeight←GetListViewItemHeight n.List
      height←5+n.List.Posn[0]+fac×lineHeight
      height+←(4+lineHeight)×0≠≢n.∆parms.colTitles
      :If 0=≢n.List.ReportInfo
          width←⌈/1⊃¨n.List.GetTextSize¨n.List.Items
      :Else
          buf←1⊃n.List.GetTextSize(4+⌈/≢¨n.List.Items)⍴'W'
          buf+←1⊃n.List.GetTextSize({+/(2+≢⍵)+⍵}↑¨⌈⌿≢¨n.List.ReportInfo)⍴'W'
          width←buf
      :EndIf
      width⌈←n.∆Hgap+1⊃↑+/↑¯1↑n.∆buttons.(Posn Size)      ⍝ Take right-most button into account
      width⌈←n.Info.Size[1]+2×n.∆Hgap                     ⍝ Take the "Info" field into account
      corr←##.APLGuiUtils.RefToWinSys.(GetSystemMetrics SM_CYCAPTION)
      corr+←##.APLGuiUtils.RefToWinSys.(GetSystemMetrics SM_CYMENU)
      height+←corr
      height+←n.Btn_00.Size[0]
      width+←30×n.List.CheckBoxes
      fntObj←⎕NEW'Font'((⊂¨'PName' 'Weight' 'Size'),¨⊂∘{(' '=1↑0⍴⍵):⍵~⎕UCS 0 ⋄ |⍵}¨##.APLGuiUtils.RefToWinSys.GetFormCaptionFontInfo[13 4 0])
      btns←##.APLGuiUtils.RefToWinSys.(GetSystemMetrics SM_CXICON)×1+n.∆Form.(SysMenu+MaxButton+MinButton)
      width⌈←btns+1⊃n.∆Form.GetTextSize n.∆Form.Caption fntObj
      width⌈←##.APLGuiUtils.CalcSizeOfFormCaption n
      available←##.APLGuiHelpers.MonitorEstate
      :If height>available[0]
          height←available[0]           ⍝ But not more than the size of the screen
      :EndIf
      :If width>available[1]
          width←available[1]            ⍝ But not more than the size of the screen
          height+←2+##.APLGuiUtils.RefToWinSys.(GetSystemMetrics SM_CXVSCROLL)
      :EndIf
      size←height,width
      :If 0<⎕NC'maxPercentage'
          size⌊←⌊(0.01×maxPercentage)×##.APLGuiHelpers.ScreenEstate-corr
      :EndIf
      size←n.∆parms.size{(0=≢⍺):⍵ ⋄ ⍺}¨size
      size←n.∆parms.minSize{(0=≢⍺):⍵ ⋄ ⍺⌈⍵}¨size
    ∇

    ∇ {r}←OnColumnClick msg;rf;colNo;mb;ss;bool;vals;isNum;ind;data;n;sel;ci;nci
      ⍝ Sort the rows
      r←⍬
      (rf colNo mb ss)←msg[0 2 3 4]         ⍝ Ref, col no, mouse button (1=left), shift state
      n←GetRefTo_n rf
      →((1≠mb)∨(0≠ss))/0                    ⍝ Only when left mouse button and no shift state
      data←⊃{0=≢⍵:⍪⍺ ⋄ ⍺,⍵}/rf.(Items ReportInfo)
      (bool vals)←↓⍉⊃⎕VFI∘⍕¨data[;colNo]
      :If 0=isNum←∧/∊bool
          vals←data[;colNo]
      :EndIf
      :If rf.∆orderedBy[1]∊0 ¯1             ⍝ Wasn't it ordered yet or ordered ↓?
          :If isNum
              ind←⍋∊vals
          :Else
              ind←⍋⊃vals
          :EndIf
          rf.∆orderedBy[1]←1
      :Else
          :If isNum
              ind←⍒∊vals
          :Else
              ind←⍒⊃vals
          :EndIf
          →(↑≠/⍴¨ind rf.Items)/0            ⍝ ∊vals might return an empty vector!
          rf.∆orderedBy[1]←0
      :EndIf
      ci←n.∆origOrder[GetCurrentItemNo n.List]  ⍝ Current item
      sel←GetSelection n
      sel←sel[ind]
      rf.Items←rf.Items[ind]
      :If 0≠≢rf.ReportInfo
          rf.ReportInfo←rf.ReportInfo[ind;]
      :EndIf
      :If 0<n.⎕NC'∆data'                    ⍝ SelectionTool has no "∆data"
      :AndIf 2=⍴⍴n.∆data
          n.∆data←n.∆data[ind;]
      :EndIf
      n.∆origOrder←n.∆origOrder[ind]
      nci←n.∆origOrder⍳ci                   ⍝ New current item
      {}rf n∘{SetItemState ⍺,⍵}¨⍸sel
      {}SetFocusTo rf nci
      :If 'ProcessTool'≡n.∆parms.parmType
      :AndIf 0≠≢n.∆parms.data
          :If 2=⍴⍴n.∆parms.data
              n.∆parms.data←n.∆parms.data[ind;]
          :Else
              n.∆parms.data←n.∆parms.data[ind]
          :EndIf
      :EndIf
      rf.ColTitles←{⍵↓⍨+/∧\' '=⍵}¨rf.ColTitles~¨⊂'↑↓'
      (colNo⊃rf.ColTitles)←('↑↓'[rf.∆orderedBy[1]]),' ',colNo⊃rf.ColTitles
      rf.∆orderedBy[0]←colNo
    ∇

      OnClose←{
          n←##.APLGuiUtils.GetRefTo_n 0⊃⍵
          _←##.APLGuiHelpers.SavePosnAndSizeInRegistry n
          ⊢n.∆Form.∆closed←1
      }

    ∇ {r}←n SelectItems bool;b;ci
      r←⍬
      :If n.∆parms.checkboxes
          :If ¯1≡bool
              n.List.SelItems{1↑⍨≢⍺}←⍬
              {}SetFocusTo n.List 0
          :Else
              :For ci :In ⍸bool
                  b←n.List GetItemState ci
                  b[12]←~b[12]
                  {}n.List.SetItemState ci(Power2 b)
              :EndFor
              {}SetFocusTo n.List(¯1↑⍸bool)
          :EndIf
      :Else
          :If ¯1≡bool
              n.List.SelItems←(≢n.List.Items)↑1
          :Else
              n.List.SelItems{∨/~⍵∊0 1:(⍳≢⍺)∊⍵ ⋄ ⍵}←bool
          :EndIf
          {}SetFocusTo n.List(n.List.SelItems⍳1)
      :EndIf
    ∇

    ∇ r←ToggleCurrentItem rf;ci;b
      r←⍬
      ci←GetCurrentItemNo rf            ⍝ Current Item is...
      :If (rf.Style≡'Multi')∨rf.CheckBoxes
          :If rf.CheckBoxes
              b←rf GetItemState ci
              :If rf.CheckBoxes
                  b[12]←~b[12]              ⍝ Check box
              :Else
                  b[1]←~b[1]                ⍝ SelItem
              :EndIf
              2 ⎕NQ rf'SetItemState'(ci)(Power2 b)  ⍝ Don't call the method: bug 10925
          :EndIf
      :Else
          rf.SelItems[ci]←~rf.SelItems[ci]
      :EndIf
    ∇

    ∇ r←(f EnPassant)r
    ⍝ Useful to execute no-result-returning stuff in a dfns.
    ⍝ Thanks to Phil Last.
      f r
    ∇

    ∇ keys←GetSpecialKeys dummy;myKC
    ⍝ The result of this functions will become the left argument to
    ⍝ a "KeyPress" event callback. Introduced for improved performance.
      myKC←⎕NEW ##.KeyCodes
      keys←⎕NS''
      keys.(home end blank cursorUp cursorDown enter)←36 35 32 38 40 13
      keys.all←keys.{⍎¨⎕NL-2}⍬
    ∇

⍝ Menubar callbacks for standard edit operations

    ∇ n OnSelectAll msg;_
    ⍝ Called only if the ListView allows selection of multiple items
      ⎕NQ n.List RefreshEvent
      :If n.List.CheckBoxes
          _←n.List{
              b←⍺ GetItemState ⍵
              b[12]←1
              2 ⎕NQ ⍺'SetItemState'⍵(Power2 b)   ⍝ Don't call the method: bug 10925
          }¨⍳≢n.List.Items
      :Else
          n.List.SelItems{⍵⍴⍨≢⍺}←1
      :EndIf
    ∇

    ∇ n OnSelectNone msg;_
      ⎕NQ n.List RefreshEvent
      :If n.List.CheckBoxes
          _←n.List{
              b←n.List GetItemState ⍵
              b[12]←0
              ⍺.SetItemState ⍵(Power2 b)
          }¨⍳≢n.List.Items
      :Else
          n.List.SelItems{⍵⍴⍨≢⍺}←0
      :EndIf
    ∇

    ∇ n OnInvertSelection msg;_
      ⎕NQ n.List RefreshEvent
      :If n.List.CheckBoxes
          _←n.List{
              b←n.List GetItemState ⍵
              b[12]←~b[12]
              ⍺.SetItemState ⍵(Power2 b)
          }¨⍳≢n.List.Items
      :Else
          n.List.(SelItems←~SelItems)
      :EndIf
    ∇

    ∇ r←CalcSizeOfListView(n posn);height
      r←n.∆Form.Size
          ⍝ Start of list control + size of statusbar + size of button + two vGaps:
      :If 0=n.⎕NC'Statusbar'
          height←0
      :Else
          height←n.Statusbar.Size[0]
      :EndIf
      r[0]-←posn[0]+height+n.(∆Vgap+∆initialVgap)+0⊃↑n.∆buttons.Size
      r[1]-←n.∆Hgap×2     ⍝ Left and right gaps
    ∇

:EndNamespace
