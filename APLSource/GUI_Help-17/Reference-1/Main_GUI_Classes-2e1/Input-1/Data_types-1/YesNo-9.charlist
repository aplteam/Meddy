# YesNo

## Overview

This results either in a single check box or in a group with two or more checkboxes. This depends
on the contents of the "label" column in the definition matrix:

* If it does not contain a `⋄` then the result is a single check box. The label defines the caption.
* If it *does* contain a `⋄` then this is treated as a separator. After splitting the label text up there will be as many checkboxes as 
  there are `⋄` plus 1. Those are put into a group.


Note that with multiple check boxes the "Default" column may be a vector of the same length. If it
is a scalar however this scalar will be extended.

Notes:

* For a single checkbox there will be a single Boolean in the result matrix, while a check box group results in a vector of Booleans.
* Both single and multiple check boxes are "smoothed", meaning that they are positioned not exactly on the grid vertically, but somewhere in between.
* In case you specify "props": those are affecting the group, not the check boxes.
* For multiple check boxes: when the number of captions is 1 plus the length of "Default" then the first item is taken as group caption. 
  Otherwise the control name is transformed into a group caption.


Note that with multiple check boxes the "Default" column may be a vector of the same length. If it
is a scalar however this scalar will be extended.

In case of a check box group the main object is the group. That means that in case you named the
check box "options" you get this within the `n` namespace, but it is the group:

~~~
      n.options
#.GUI.StdForm.[Form].[SubForm].[Group]
~~~

`⎕WN` returns a list of the actuall check box controls when fed with the group:

~~~
    {(↑⍵) (⍴⍵)}⎕wn n.options
#.GUI.StdForm.[Form].[SubForm].[Group].[Button]  4 
~~~

Note that the check boxes belonging to that group will be named `n.options_check_{nn}` with `nn`
being a running number that starts from "00".

~~~
     n.options_check_00
#.GUI.StdForm.[Form].[SubForm].[Group].[Button]
~~~

## Smoothing

Note that check boxes are one of the data types that are subject of →[*.Smoothing|smoothing].

## Example

~~~
DT←#.GUI.Enums.InputDataTypes
msg←'There are several options available⋄for starting Dyalog APL.⋄Please select the appropriate one:'
defMat←⍉⍪'Info' msg '' DT.Label 0 1 1
list←'My special options⋄F32⋄Dyalog_5977⋄PropertyExposed⋄Ask for a Ride'
defMat⍪←'Options' list (1 1 0 0) DT.YesNo 0 1 1
#.GUI.Input.Run defMat
~~~

This results in this GUI:

![](.\Images\DataTypes\YesNo_01.png)

Note that in this example the list contained 4 `⋄`, therefore the list contained 5 items while the
vector of Booleans in "Default" had only 4 items. That's why "My special options" made it into the
caption of the group.

If we remove the first item (= the string "My special options") from that list then `Input`
realises that the label must be missing and therefore uses the name to make it up:

~~~
list←'F32⋄Dyalog_5977⋄PropertyExposed⋄Ask for a Ride'
defMat⍪←'Options'list(1 1 0 0)DT.YesNo 0 1 1
#.GUI.Input.Run defMat
~~~

![](.\Images\DataTypes\YesNo_02.png)

Note however that if "Default" is a scalar then `Input` has no way to determine whether the label
is included or not; therefore you **must** specify the caption of the group in the first item in
case "Default" is a scalar.
