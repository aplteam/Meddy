# Layout principles in Input

## Overview: the layout grid

`Input` uses the concept of a layout  grid. A layout grid has rows and columns. The basic input
control that defines a single unit of "height" are all edit fields like the data types "Character",
"Numeric" and "Currency" but also those disguising that they are actually stemming from an "Edit"
like "DropDown" and "DropEdit".

Those  - together with the associated label - define what the standard height of a single row in
the grid is. This means of course that the height is influenced by the fonts used.

The distance between rows is defined by `→[*.Gaps_between_controls|Vgap]`. Some controls, like
"Notepad" and "ListView", define their height as multiples of the standard height.

But there are controls that don't fit (like "YesNo") or their height is defined by external
conditions; the height of a group of radio buttons or check boxes, for example, or an image.
`Input` figures out how many standard units those controls actually occupy and makes sure that
the control is placed as well as possible.

This strategy ensures that with multiple columns all controls that stem from the "Edit" control
will line up properly even when something bigger/smaller than a standard row is positioned between them.

Sometimes you might not be happy how rows fall into place in different columns. In that case it
might help to insert a →[*.PlaceHolder]. If that's not sufficient then you can define a function
that is called by `Input` after all controls were created but before the form gets its final size;
see xxx for details.
                    

## Rows

## Columns

By default `Input` creates all controls vertically as shown here:

~~~
DT←#.GUI.Enums.InputDataTypes
defMat⍪←0 7⍴0
defMat⍪←'DateTS' 'Date as []TS' ⎕TS DT.Date 0 1 1
defMat⍪←'DateInt' 'Date as integer' 20151029 DT.Date 0 1 1
defMat⍪←'DateChar' 'Date as Character' '2015-10-29' DT.Date 0 1 1
defMat⍪←'TimeInt' 'Int' 81234 DT.Time 0 1 1
defMat⍪←'TimeFloat' 'Float' 0.081234 DT.Time 0 1 1
defMat⍪←'TimeChar' 'Char' '08:12:34'DT.Time 0 1 1
    ⎕←defMat
DateTS     Date as []TS       2015 11 1 18 23 23 691   5 0 1 1
DateInt    Date as integer           20151029          5 0 1 1
DateChar   Date as Character              2015-10-29   5 0 1 1
TimeInt    Int                          81234         18 0 1 1
TimeFloat  Float                            0.081234  18 0 1 1
TimeChar   Char                             08:12:34  18 0 1 1
~~~

This is how the GUI looks like:

![](.\Images\Input\01.png)

You can change this by specifying a different column in the definition matrix. Let's check the
current setting:

~~~
     ⎕←defMat[;#.GUI.Enums.DefMatIndices.Column]
1 1 1 1 1 1
~~~

There is just one column specified, so that's what we got. Let's change this so that the first
three input fields go into the first column and the remaining into the second column:

~~~
    defMat[3+⍳3;#.GUI.Enums.DefMatIndices.Column]←2
     ⎕←defMat[;#.GUI.Enums.DefMatIndices.Column]
1 1 1 2 2 2
~~~

With this new definition matrix we get this:

![](.\Images\Input\02.png)

~~~
    defMat[;#.GUI.Enums.DefMatIndices.Column]←0 1 1 2 2 2
~~~

Now we get three columns:

![](.\Images\Input\03.png)

Note that this time we specified 0 rather than 1 for the first column; it does not really matter,
`Input` figures out whether you use `⎕IO←0` or `⎕IO←1` mentally. In fact you could use 2, 4 and 5
and get exactly the same result. The only important thing is that if the number changes it is a
higher one.
